{
  "problems": [
    {
      "id": "018fe6f3-5e85-7b8c-a83f-d68464ee07e4",
      "category_id": "018fe6e3-6c04-79eb-997b-3153f285556f",
      "name": "Meeting Rooms (Leetcode Premium)",
      "slug": "meeting-rooms",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/meeting-rooms/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/PaJxqZVPhbg",
      "solution": "/**\r\n * @param {Interval[]} intervals\r\n * @returns {boolean}\r\n */\r\nvar canAttendMeetings = (intervals) => {\r\n    DeetCode.array(\"intervals\", intervals);\r\n    intervals.sort((a, b) => a.start - b.start);\r\n    DeetCode.array(\"intervals\", intervals);\r\n    let prev = null;\r\n    for (const interval of intervals) {\r\n        if (prev !== null) {\r\n            if (prev.end > interval.start) {\r\n                return false;\r\n            }\r\n            if (prev.start > interval.start) {\r\n                return false;\r\n            }\r\n        }\r\n        prev = interval;\r\n    }\r\n    return true;\r\n}\r\n\r\nconst intervals = [{start: 0, end: 30}, {start: 5, end: 10}, {start: 15, end: 20}];\r\nconst res = canAttendMeetings(intervals);\r\nDeetCode.equal(res, false);",
      "notes": null,
      "neetcode_notes": "sort intervals by start time, if second interval doesn’t overlap with first, then third def wont overlap with first;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5e8b-72a8-8305-cfd7d88b08ee",
      "category_id": "018fe6e3-6bdd-7575-89fe-a18ebfad9a68",
      "name": "Number of 1 Bits",
      "slug": "number-of-1-bits",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/number-of-1-bits/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/5Km3utixwZs",
      "solution": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar hammingWeight = function(n) {\r\n    let res = 0;\r\n    while (n) {\r\n        DeetCode.bitwise(\"n\", n);\r\n        if (n & 1) {\r\n            res += 1;\r\n        }\r\n        n = n >> 1;\r\n    }\r\n    return res;\r\n};\r\n\r\nconst res = hammingWeight(128);\r\nDeetCode.equal(res, 1);",
      "notes": null,
      "neetcode_notes": "modulo, and dividing n; mod and div are expensive, to divide use bit shift, instead of mod to get 1's place use bitwise & 1;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5e8d-7cfa-a4f2-85183ebc3e3e",
      "category_id": "018fe6e3-6bdd-7575-89fe-a18ebfad9a68",
      "name": "Missing Number",
      "slug": "missing-number",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/missing-number/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/WnPLSRLSANE",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar missingNumber = function(nums) {\r\n    let res = nums.length;\r\n    DeetCode.bitwise(\"res\", res);\r\n    for (let i = 0; i < nums.length; i++) {\r\n        let xor = i ^ nums[i];\r\n        res ^= xor;\r\n        DeetCode.bitwise(\"xor\", xor);\r\n        DeetCode.bitwise(\"res\", res);\r\n    }\r\n    return res;\r\n};\r\n\r\nconst res = missingNumber([3, 0, 1]);\r\nDeetCode.equal(res, 2);",
      "notes": null,
      "neetcode_notes": "compute expected sum - real sum; xor n with each index and value;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5e90-72d0-9251-e50d5f724ea5",
      "category_id": "018fe6e3-6bdd-7575-89fe-a18ebfad9a68",
      "name": "Reverse Bits",
      "slug": "reverse-bits",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/reverse-bits/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/UcoN6UjAI64",
      "solution": "/**\r\n * @param {number} n - a positive integer\r\n * @return {number} - a positive integer\r\n */\r\nvar reverseBits = function(n) {\r\n    let bit = 0;\r\n    DeetCode.bitwise(\"n\", n);\r\n    DeetCode.bitwise(\"bit\", bit);\r\n    for (let i = 0; i < 32; i++) {        \r\n        bit = bit << 1;\r\n        const firstBit = n & 1;\r\n        bit = bit | firstBit;\r\n        n = n >> 1\r\n        DeetCode.bitwise(\"n\", n);\r\n        DeetCode.bitwise(\"bit\", bit);\r\n    }\r\n    return bit;\r\n};\r\n\r\nconst res = reverseBits(43261596);\r\nDeetCode.equal(res, 964176192);",
      "notes": null,
      "neetcode_notes": "reverse each of 32 bits;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5e93-7cc7-9fd9-d9f588788a87",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Contains Duplicate",
      "slug": "contains-duplicate",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/contains-duplicate/",
      "youtube_url": "https://youtu.be/45EDYZB-324",
      "neetcode_url": "https://youtu.be/3OamzN90kPg",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nvar containsDuplicate = function(nums) {\r\n    const numSet = new Set();\r\n    for (const num of nums) {\r\n        if (numSet.has(num)) return true;\r\n        numSet.add(num);\r\n    }\r\n    return false;\r\n};\r\n\r\nconst nums = [1,2,3,1];\r\nconst res = containsDuplicate(nums);\r\nDeetCode.equal(res, true);",
      "notes": "Loop through numbers. Use a hash set to track unique values and check for duplicates.",
      "neetcode_notes": "hashset to get unique values in array, to check for duplicates easily",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": ""
    },
    {
      "id": "018fe6f3-5e96-7eaf-ad53-daa7c9fe927a",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Subtree of Another Tree",
      "slug": "subtree-of-another-tree",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/subtree-of-another-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/E36O5SWp-LE",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} subRoot\r\n * @return {boolean}\r\n */\r\nvar isSubtree = function(root, subRoot) {\r\n    root.color = \"green\";\r\n    DeetCode.tree(\"r\", r);\r\n    if (!root && !subRoot) {\r\n        return true;\r\n    }\r\n\r\n    if (!root && subRoot) {\r\n        return false;\r\n    }\r\n\r\n    if (isSame(root, subRoot)) {\r\n        return true;\r\n    }\r\n\r\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\r\n};\r\n\r\nvar isSame = function (q, p) {\r\n    if (!p && !q) {\r\n        return true;\r\n    }\r\n\r\n    if (!p || !q) {\r\n        return false;\r\n    }\r\n\r\n    if (p.val !== q.val) {\r\n        return false;\r\n    }\r\n\r\n    return isSame(p.left, q.left) && isSame(p.right, q.right);\r\n}\r\n\r\nconst r = DeetCode.arrayToBinaryTree([3,4,5,1,2])\r\nconst s = DeetCode.arrayToBinaryTree([4,1,2])\r\nDeetCode.tree(\"r\", r);\r\nDeetCode.tree(\"s\", s);\r\nconst res = isSubtree(r, s);\r\nDeetCode.equal(res, true);",
      "notes": null,
      "neetcode_notes": "traverse s to check if any subtree in s equals t; merkle hashing?",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5e98-77c8-8d07-94e0205e6fed",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Maximum Subarray",
      "slug": "maximum-subarray",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/maximum-subarray/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/5WZl3MMT0Eg",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxSubArray = function(nums) {\r\n    let max = nums[0];\r\n    const dp = new Array(nums.length);\r\n    dp[0] = max;\r\n    for (let i = 1; i < nums.length; i++) {\r\n        DeetCode.array(\"dp\", dp, {pointers: {i}});\r\n        dp[i] = Math.max(nums[i], nums[i] + dp[i-1]);\r\n        max = Math.max(max, dp[i]);\r\n    }\r\n    return max;\r\n};\r\n\r\nconst nums = [-2,1,-3,4,-1,2,1,-5,4];\r\nconst res = maxSubArray(nums);\r\nDeetCode.equal(res, 6);",
      "notes": "The trick to achieving an O(N) time complexity is to use dynamic programming to cache the best you can do at each index. The best you can do at each index would be the value itself or the value itself plus the value that came before it. \r\n\r\ndp[i] = max(dp[i], dp[i] + dp[i-1])",
      "neetcode_notes": "pattern: prev subarray cant be negative, dynamic programming: compute max sum for each prefix",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5e9a-77eb-8021-c35a21c78eb4",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Maximum Depth of Binary Tree",
      "slug": "maximum-depth-of-binary-tree",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/hTM3phVI6YQ",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if (!root) {\r\n        return 0;\r\n    }\r\n    root.color = \"green\";\r\n    DeetCode.tree(\"rootnode\", rootnode);\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n\r\nconst rootnode = DeetCode.arrayToBinaryTree([3,9,20,null,null,15,7]);\r\nconst res = maxDepth(rootnode);\r\nDeetCode.equal(res, 3);",
      "notes": null,
      "neetcode_notes": "recursive dfs to find max-depth of subtrees; iterative bfs to count number of levels in tree",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5e9d-729f-9c0d-ac8e0679fb00",
      "category_id": "018fe6e3-6bfa-731a-8eda-f5924821d196",
      "name": "Detect Cycle in a Linked List",
      "slug": "linked-list-cycle",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/linked-list-cycle/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/gBTe7lFR3vc",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {boolean}\r\n */\r\nvar hasCycle = function(head) {\r\n    DeetCode.linkedList(\"1\", head);\r\n    const set = new Set();\r\n    let cur = head;\r\n    while (cur) {\r\n        if (set.has(cur.val)) {\r\n            return true;\r\n        }\r\n        set.add(cur.val);\r\n        cur = cur.next;\r\n    }\r\n    return false;\r\n};\r\n\r\nconst head = new ListNode(3);\r\nhead.next = new ListNode(2);\r\nhead.next.next = new ListNode(0);\r\nhead.next.next.next = new ListNode(4);\r\nhead.next.next.next.next = head.next; // cycle\r\n\r\nconst res = hasCycle(head);\r\nDeetCode.equal(res, true);\r\n\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {boolean}\r\n */\r\nvar hasCycle2 = function(head) {\r\n    let slow = head;\r\n    let fast = head;\r\n    DeetCode.linkedList(\"2\", head, {pointers: {slow, fast}})\r\n    while (fast && fast.next) {\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n        DeetCode.linkedList(\"2\", head, {pointers: {slow, fast}})\r\n        if (slow === fast) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nconst res2 = hasCycle2(head);\r\nDeetCode.equal(res2, true);\r\n",
      "notes": null,
      "neetcode_notes": "dict to remember visited nodes; two pointers at different speeds, if they meet there is loop",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ea0-7bb5-9c53-cf577340c784",
      "category_id": "018fe6e3-6bfa-731a-8eda-f5924821d196",
      "name": "Merge Two Sorted Lists",
      "slug": "merge-two-sorted-lists",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/merge-two-sorted-lists/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/XIdigk956u0",
      "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} list1\r\n * @param {ListNode} list2\r\n * @return {ListNode}\r\n */\r\nvar mergeTwoLists = function(list1, list2) {\r\n    let p1 = list1;\r\n    let p2 = list2;\r\n    const dummy = new ListNode();\r\n    let cur = dummy;\r\n    DeetCode.linkedList(\"p1\", p1, {pointers: {p1, cur}});\r\n    DeetCode.linkedList(\"p2\", p2, {pointers: {p2, cur}});\r\n    DeetCode.linkedList(\"dummy\", dummy, {pointers: {dummy, cur}});\r\n    while (p1 || p2) {\r\n        if (p1 && p2) {\r\n            if (p1.val < p2.val) {\r\n                cur.next = p1;\r\n                p1 = p1.next;\r\n                DeetCode.linkedList(\"p1\", p1, {pointers: {p1, cur}});\r\n            } else {\r\n                cur.next = p2;\r\n                p2 = p2.next;\r\n                DeetCode.linkedList(\"p2\", p2, {pointers: {p2, cur}});\r\n            }\r\n        } else if (p1) {\r\n            cur.next = p1;\r\n            p1 = p1.next;\r\n            DeetCode.linkedList(\"p1\", p1, {pointers: {p1, cur}});\r\n        } else if (p2) {\r\n            cur.next = p2;\r\n            p2 = p2.next;\r\n            DeetCode.linkedList(\"p2\", p2, {pointers: {p2, cur}});\r\n        }\r\n        cur = cur.next;\r\n        DeetCode.linkedList(\"dummy\", dummy, {pointers: {dummy, cur}});\r\n    }\r\n    return dummy.next;\r\n};\r\n\r\nconst list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\r\nconst list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\r\nconst res = mergeTwoLists(list1, list2);\r\nconsole.log(res);",
      "notes": null,
      "neetcode_notes": "insert each node from one list into the other",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ea3-73c8-923a-218234a769f7",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Valid Palindrome",
      "slug": "valid-palindrome",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/valid-palindrome/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/jJXJ16kPFWg",
      "solution": "/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar isPalindrome = function(s) {\r\n    const str = s.toLocaleLowerCase().replace(/[^A-Za-z0-9]/g, \"\");\r\n    let l = 0;\r\n    let r = str.length - 1;\r\n\r\n    DeetCode.string(\"str\", str, {pointers: {l, r}});\r\n\r\n    while (l < r) {\r\n        if (str[l] !== str[r]) {\r\n            return false;\r\n        }\r\n        l++;\r\n        r--;\r\n        DeetCode.string(\"str\", str, {pointers: {l, r}});\r\n    }\r\n    return true;\r\n};\r\n\r\nconst s = \"A man, a plan, a canal: Panama\";\r\nconst res = isPalindrome(s);\r\nDeetCode.equal(res, true);",
      "notes": null,
      "neetcode_notes": "left, right pointers, update left and right until each points at alphanum, compare left and right, continue until left >= right, don’t distinguish between upper/lowercase;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ea5-7e55-87af-b25f632b5081",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Lowest Common Ancestor of BST",
      "slug": "lowest-common-ancestor-of-a-binary-search-tree",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/gs2LMfuOR9k",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {TreeNode}\r\n */\r\nvar lowestCommonAncestor = function(root, p, q) {\r\n    while (root) {\r\n        root.color = \"green\";\r\n        DeetCode.tree(\"rootNode\", rootNode);\r\n        if (root.val < p.val && root.val < q.val) {\r\n            root = root.right;\r\n            continue;\r\n        }\r\n\r\n        if (root.val > p.val && root.val > q.val) {\r\n            root = root.left;\r\n            continue;\r\n        }\r\n\r\n        return root;\r\n    }\r\n};\r\n\r\nconst rootNode = new TreeNode(6);\r\n    rootNode.left = new TreeNode(2);\r\n        rootNode.left.left = new TreeNode(0);\r\n        rootNode.left.right = new TreeNode(4);\r\n            rootNode.left.right.left = new TreeNode(3);\r\n            rootNode.left.right.right = new TreeNode(5);\r\n    rootNode.right = new TreeNode(8);\r\n        rootNode.right.left = new TreeNode(7);\r\n        rootNode.right.right = new TreeNode(9);\r\n\r\nDeetCode.tree(\"rootNode\", rootNode);\r\n\r\nconst res = lowestCommonAncestor(rootNode, rootNode.left.right.left, rootNode.left.right.right);\r\nDeetCode.equal(res.val, 4);",
      "notes": null,
      "neetcode_notes": "compare p, q values to curr node, base case: one is in left, other in right subtree, then curr is lca;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ea8-7e2c-836c-6d4a0c72e8d7",
      "category_id": "018fe6e3-6bdd-7575-89fe-a18ebfad9a68",
      "name": "Sum of Two Integers",
      "slug": "sum-of-two-integers",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/sum-of-two-integers/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/gVUrDV4tZfY",
      "solution": "/**\r\n * @param {number} a\r\n * @param {number} b\r\n * @return {number}\r\n */\r\nvar getSum = function(a, b) {\r\n    DeetCode.bitwise(\"a\", a);\r\n    DeetCode.bitwise(\"b\", b);\r\n    while (b !== 0) {\r\n        const xor = (a ^ b);\r\n        const carry = (a & b) << 1;\r\n        a = xor;\r\n        b = carry;\r\n        DeetCode.bitwise(\"a\", a);\r\n        DeetCode.bitwise(\"b\", b);\r\n    }\r\n    return a;\r\n};\r\n\r\nconst res = getSum(1,2);\r\nDeetCode.equal(res, 3);",
      "notes": null,
      "neetcode_notes": "add bit by bit, be mindful of carry, after adding, if carry is still 1, then add it as well;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eaa-772a-a614-975c1aa5504c",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Climbing Stairs",
      "slug": "climbing-stairs",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/climbing-stairs/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/Y0lT9Fck7qI",
      "solution": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar climbStairs = function(n) {\r\n    const dp = Array(n+1);\r\n    for (let i = 0; i < n + 1; i++) {\r\n        if (i === 0) {\r\n            dp[i] = 0;\r\n        } else if (i === 1) {\r\n            dp[i] = 1;\r\n        } else if (i === 2) {\r\n            dp[i] = 2;\r\n        } else {\r\n            dp[i] = dp[i-1] + dp[i-2];\r\n        }\r\n        DeetCode.array(\"dp\", dp, {pointers: {i}});\r\n    }\r\n    return dp[n];\r\n};\r\n\r\nconst res = climbStairs(10);\r\nDeetCode.equal(res, 89);",
      "notes": null,
      "neetcode_notes": "subproblem find (n-1) and (n-2), sum = n;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eac-723c-9329-1588aa962e0a",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Invert/Flip Binary Tree",
      "slug": "invert-binary-tree",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/invert-binary-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/OnSn2XEQ4MY",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar invertTree = function(root) {\r\n    if (!root) return root;\r\n    root.color = \"green\";\r\n    DeetCode.tree(\"rootnode\", rootnode);\r\n    const tmp = root.left;\r\n    root.left = root.right;\r\n    root.right = tmp;\r\n    invertTree(root.left);\r\n    invertTree(root.right);\r\n    return root;\r\n};\r\n\r\nconst rootnode = DeetCode.arrayToBinaryTree([4,2,7,1,3,6,9]);\r\nDeetCode.tree(\"rootnode\", rootnode);\r\nconst res = invertTree(rootnode);",
      "notes": null,
      "neetcode_notes": "recursive dfs to invert subtrees; bfs to invert levels, use collections.deque; iterative dfs is easy with stack if doing pre-order traversal",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eae-7f94-9ce7-723862dd885a",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Valid Anagram",
      "slug": "valid-anagram",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/valid-anagram/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/9UtInBqnCgA",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {boolean}\r\n */\r\nvar isAnagram = function(s, t) {\r\n    const map = new Map();\r\n    for (const c of s) {\r\n        const count = map.get(c) || 0;\r\n        map.set(c, count + 1);\r\n    }\r\n    for (const c of t) {\r\n        const count = map.get(c) || 0;\r\n        map.set(c, count - 1);\r\n    }\r\n    for (const [k, v] of map.entries()) {\r\n        if (v !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nconst res = isAnagram(\"anagram\", \"nagaram\");\r\nDeetCode.equal(res, true);",
      "notes": "Use a hash map. Count each characters in s. Decrement each character in t. It is anagram if all values in hash map are 0.",
      "neetcode_notes": "hashmap to count each char in str1, decrement for str2;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eb1-78bd-b888-94fecd59e1b6",
      "category_id": "018fe6e3-6bfa-731a-8eda-f5924821d196",
      "name": "Reverse Linked List",
      "slug": "reverse-linked-list",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/reverse-linked-list/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/G0_I-ZF0S38",
      "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar reverseList = function(head) {\r\n    let prev = null;\r\n    let cur = head;\r\n    while (cur) {\r\n        const next = cur.next;\r\n        cur.next = prev;\r\n        prev = cur;\r\n        cur = next;\r\n        DeetCode.linkedList(\"cur\", cur, {pointers: {prev, cur}});\r\n        DeetCode.linkedList(\"prev\", prev, {pointers: {prev, cur}});\r\n    }\r\n    return prev;\r\n};\r\n\r\n// const head = new ListNode(1);\r\n// head.next = new ListNode(2);\r\n// head.next.next = new ListNode(3);\r\n// head.next.next.next = new ListNode(4);\r\n// head.next.next.next.next = new ListNode(5);\r\n\r\nconst head = DeetCode.arrayToLinkedList([1, 2, 3, 4, 5]);\r\nDeetCode.linkedList(\"head\", head);\r\n\r\nconst res = reverseList(head);\r\nconsole.log(res);",
      "notes": null,
      "neetcode_notes": "iterate through maintaining cur and prev; recursively reverse, return new head of list",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eb3-7fe9-a05b-e57c68b838e3",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "House Robber",
      "slug": "house-robber",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/house-robber/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/73r3KWiEvyk",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar rob = function(nums) {\r\n    const dp = new Array(nums.length);\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (i === 0) {\r\n            dp[i] = nums[i];\r\n        } else if (i === 1) {\r\n            dp[i] = Math.max(nums[i], dp[i-1]);\r\n        } else {\r\n            dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);\r\n        }\r\n    }\r\n    return dp[nums.length - 1];\r\n};\r\n\r\nconst res = rob([2,7,9,3,1]);\r\nDeetCode.equal(res, 12);",
      "notes": null,
      "neetcode_notes": "for each num, get max of prev subarr, or num + prev subarr not including last element, store results of prev, and prev not including last element",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eb5-7aa8-bd9e-7c03df2caad9",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Best Time to Buy and Sell Stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/1pkOgXD63yU",
      "solution": "/**\r\n * @param {number[]} prices\r\n * @return {number}\r\n */\r\nvar maxProfit = function(prices) {\r\n    let l = 0;\r\n    let r = 0;\r\n    DeetCode.array(\"prices\", prices, {pointers: {l, r}});\r\n    let max = 0;\r\n    while (l < prices.length && r < prices.length) {\r\n        let profit = prices[r] - prices[l];\r\n        max = Math.max(max, profit);\r\n        if (prices[r] < prices[l]) {\r\n            l++;\r\n            DeetCode.array(\"prices\", prices, {pointers: {l, r}});\r\n            continue;\r\n        }\r\n        r++;\r\n        DeetCode.array(\"prices\", prices, {pointers: {l, r}});\r\n    }\r\n    return max;\r\n};\r\n\r\nconst prices = [7,1,5,3,6,4];\r\nconst res = maxProfit(prices);\r\nDeetCode.equal(res, 5);",
      "notes": "A sliding window approach. Increment the left pointer if the right value is lower. Otherwise, increment the right pointer. Keep track of the max profit.",
      "neetcode_notes": "find local min and search for local max, sliding window;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": ""
    },
    {
      "id": "018fe6f3-5eb8-7e39-846a-ca52a796eb2b",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Same Tree",
      "slug": "same-tree",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/same-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/vRbbcKXCxOw",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if (!p && !q) {\r\n        return true;\r\n    }\r\n\r\n    if (!p || !q) {\r\n        return false;\r\n    }\r\n\r\n    p.color = \"green\";\r\n    q.color = \"green\";\r\n    DeetCode.tree(\"proot\", proot);\r\n    DeetCode.tree(\"qroot\", qroot);\r\n\r\n    if (p.val !== q.val) {\r\n        return false;\r\n    }\r\n\r\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));\r\n};\r\n\r\nconst proot = new TreeNode(1);\r\nproot.left = new TreeNode(2);\r\nproot.right = new TreeNode(3);\r\n\r\nconst qroot = new TreeNode(1);\r\nqroot.left = new TreeNode(2);\r\nqroot.right = new TreeNode(3);\r\n\r\nconst res = isSameTree(proot, qroot);\r\nDeetCode.equal(res, true);\r\n",
      "notes": null,
      "neetcode_notes": "recursive dfs on both trees at the same time; iterative bfs compare each level of both trees",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eba-7c29-a5fe-fd7b6ec2bb78",
      "category_id": "018fe6e3-6c03-7e0e-97b3-eec9ced5f80f",
      "name": "Top K Frequent Elements",
      "slug": "top-k-frequent-elements",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/top-k-frequent-elements/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/YPTqKIgVk-k",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar topKFrequent = function(nums, k) {\r\n    const map = new Map();\r\n    for (const num of nums) {\r\n        const count = map.get(num) || 0;\r\n        map.set(num, count + 1);\r\n    }\r\n    const pq = new PriorityQueue((a, b) => b.count - a.count);\r\n    for (const [num, count] of map.entries()) {\r\n        console.log({num, count})\r\n        pq.enqueue({num, count});\r\n    }\r\n    const res = [];\r\n    for (let i = 0; i < k; i++) {\r\n        const entry = pq.dequeue();\r\n        res.push(entry.num);\r\n    }\r\n    return res;\r\n};\r\n\r\nconst nums = [1,1,1,2,2,3];\r\nconst res = topKFrequent(nums, 2);\r\nDeetCode.equal(res, [1,2]);\r\nconst k = 2;",
      "notes": null,
      "neetcode_notes": "minheap that’s kept at size k, if its bigger than k pop the min, by the end it should be left with k largest;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ebc-7b8f-b71a-51a4e8e8b773",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Kth Smallest Element in a BST",
      "slug": "kth-smallest-element-in-a-bst",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/5LUXSvjmGCw",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar kthSmallest = function(root, k) {\r\n    const inorder = [];\r\n    DeetCode.array(\"inorder\", inorder);\r\n    DeetCode.tree(\"input\", input);\r\n    function dfs(root) {\r\n        if (!root) {\r\n            return;\r\n        }\r\n        dfs(root.left);\r\n        root.color = \"green\";\r\n        DeetCode.tree(\"input\", input);\r\n        inorder.push(root.val);\r\n        DeetCode.array(\"inorder\", inorder);\r\n        dfs(root.right);\r\n    }\r\n    dfs(root);\r\n    return inorder[k-1];\r\n};\r\n\r\nconst input = DeetCode.arrayToBinaryTree([3,1,4,null,2]);\r\nconst res = kthSmallest(input, 1);\r\nDeetCode.equal(res, 1);",
      "notes": null,
      "neetcode_notes": "non-optimal store tree in sorted array; iterative dfs in-order and return the kth element processed, go left until null, pop, go right once;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ebf-7caa-84fe-7a155cd69e37",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Container With Most Water",
      "slug": "container-with-most-water",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/container-with-most-water/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/UuiTKBwPgAo",
      "solution": "/**\r\n * @param {number[]} height\r\n * @return {number}\r\n */\r\nvar maxArea = function(height) {\r\n    let l = 0;\r\n    let r = height.length - 1;\r\n    let res = 0;\r\n    DeetCode.array(\"height\", height, {pointers: {l, r}});\r\n    while (l < r) {\r\n        const width = r - l;\r\n        const minHeight = Math.min(height[l], height[r]);\r\n        const amount = minHeight * width;\r\n        res = Math.max(res, amount);\r\n        if (height[l] < height[r]) {\r\n            l++;\r\n        } else {\r\n            r--;\r\n        }\r\n        DeetCode.array(\"height\", height, {pointers: {l, r}});\r\n    }\r\n    return res;\r\n};\r\n\r\nconst res = maxArea([1,8,6,2,5,4,8,3,7]);\r\nDeetCode.equal(res, 49);",
      "notes": null,
      "neetcode_notes": "shrinking window, left/right initially at endpoints, shift the pointer with min height;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ec1-737f-937a-fdcb99faba51",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Course Schedule",
      "slug": "course-schedule",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/course-schedule/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/EgI5nU9etnU",
      "solution": "/**\r\n * @param {number} numCourses\r\n * @param {number[][]} prerequisites\r\n * @return {boolean}\r\n */\r\nvar canFinish = function(numCourses, prerequisites) {\r\n    const adj = new Map();\r\n    const color = new Map();\r\n    for (let i = 0; i < numCourses; i++) {\r\n        adj.set(i, []);\r\n        color.set(i, \"white\");\r\n    }\r\n    for (const [a, b] of prerequisites) {\r\n        adj.get(b).push(a);\r\n    }\r\n    DeetCode.directedGraph(\"graph\", {adj: adj, color: color});\r\n    for (let i = 0; i < numCourses; i++) {\r\n        if (color.get(i) === \"white\") {\r\n            const hasCycle = dfs(i);\r\n            if (hasCycle) return false;\r\n        }\r\n    }\r\n    function dfs(i) {\r\n        if (color.get(i) === \"green\") return false;\r\n        if (color.get(i) === \"gray\") return true;\r\n        if (color.get(i) === \"white\") {\r\n            color.set(i, \"gray\");\r\n            DeetCode.directedGraph(\"graph\", {adj: adj, color: color});\r\n            for (let nei of adj.get(i)) {\r\n                const hasCycle = dfs(nei);\r\n                if (hasCycle) return true;\r\n            }\r\n        }\r\n        color.set(i, \"green\");\r\n        DeetCode.directedGraph(\"graph\", {adj: adj, color: color});\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\n\r\nconst numCourses = 20;\r\nconst prerequisites = [[0,10],[3,18],[5,5],[6,11],[11,14],[13,1],[15,1],[17,4]];\r\nconst res = canFinish(numCourses, prerequisites);\r\nDeetCode.equal(res, false);\r\n",
      "notes": null,
      "neetcode_notes": "build adjacentcy_list with edges, run dfs on each V, if while dfs on V we see V again, then loop exists, otherwise V isnt in a loop, 3 states= not visited, visited, still visiting",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ec3-7fa0-99e8-390403e89a3c",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Unique Paths",
      "slug": "unique-paths",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/unique-paths/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/IlEsdxuD4lY",
      "solution": "/**\r\n * @param {number} m\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar uniquePaths = function(m, n) {\r\n    const dp = new Array(m).fill().map(() => new Array(n).fill(0));\r\n    DeetCode.array(\"dp\", dp);\r\n    for (let i = 0; i < m; i++) {\r\n        for (let j = 0; j < n; j++) {\r\n            if (i === 0 || j === 0) {\r\n                dp[i][j] = 1;\r\n                DeetCode.array(\"dp\", dp);\r\n                continue;\r\n            }\r\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\r\n            DeetCode.array(\"dp\", dp);\r\n        }\r\n    }\r\n    DeetCode.array(\"dp\", dp);\r\n    return dp[n-1][m-1];\r\n};\r\n\r\nconst res = uniquePaths(3, 7);\r\nDeetCode.equal(res, 28);",
      "notes": null,
      "neetcode_notes": "work backwards from solution, store paths for each position in grid, to further optimize, we don’t store whole grid, only need to store prev row;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ec5-7b56-96d4-ff8a3eb412cd",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Construct Binary Tree from Preorder and Inorder Traversal",
      "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/ihj4IQGZ2zc",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {number[]} preorder\r\n * @param {number[]} inorder\r\n * @return {TreeNode}\r\n */\r\nvar buildTree = function(preorder, inorder) {\r\n    if (!preorder.length || !inorder.length) return null;\r\n    DeetCode.array(\"preorder\", preorder);\r\n    DeetCode.array(\"inorder\", inorder);\r\n    const node = new TreeNode(preorder[0]);\r\n    DeetCode.tree(\"node\", node);\r\n    const mid = inorder.indexOf(preorder[0]);\r\n    node.left = buildTree(preorder.slice(1, mid+1), inorder.slice(0, mid));\r\n    node.right = buildTree(preorder.slice(mid+1, preorder.length), inorder.slice(mid+1, inorder.length));\r\n    return node;\r\n};\r\n\r\nconst expected = DeetCode.arrayToBinaryTree([3,9,20,null,null,15,7])\r\nDeetCode.tree(\"expected\", expected);\r\nconst preorder = [3,9,20,15,7];\r\nconst inorder = [9,3,15,20,7];\r\nconst res = buildTree(preorder, inorder);\r\nDeetCode.tree(\"res\", res);\r\nDeetCode.equal(res, expected);",
      "notes": null,
      "neetcode_notes": "first element in pre-order is root, elements left of root in in-order are left subtree, right of root are right subtree, recursively build subtrees;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ec6-7a65-aaf1-a105d7cf433d",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Longest Increasing Subsequence",
      "slug": "longest-increasing-subsequence",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/longest-increasing-subsequence/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/cjWnW0hdF1Y",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar lengthOfLIS = function(nums) {\r\n    const dp = new Array(nums.length).fill(1);\r\n    dp[0] = 1;\r\n    DeetCode.array(\"dp\", dp);\r\n    for (let i = 1; i < nums.length; i++) {\r\n        for (let j = 0; j < i; j++) {\r\n            DeetCode.array(\"dp\", dp, {pointers: {i, j}});\r\n            if (nums[i] > nums[j]) {\r\n                dp[i] = Math.max(dp[i], dp[j] + 1);\r\n            }\r\n        }\r\n    }\r\n    DeetCode.array(\"dp\", dp);\r\n    return Math.max(...dp);\r\n};\r\n\r\nconst input = [10,9,2,5,3,7,101,18];\r\nDeetCode.array(\"input\", input);\r\nconst res = lengthOfLIS(input);\r\nDeetCode.equal(res, 4);",
      "notes": null,
      "neetcode_notes": "recursive: foreach num, get subseq with num and without num, only include num if prev was less, cache solution of each; dp=subseq length which must end with each num, curr num must be after a prev dp or by itself;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ec8-7952-b1fd-3b15dcf13e2b",
      "category_id": "018fe6e3-6c01-7c9d-8225-5802bc33ef41",
      "name": "Rotate Image",
      "slug": "rotate-image",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/rotate-image/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/fMSJSS7eO1w",
      "solution": "/**\r\n * @param {number[][]} matrix\r\n * @return {void} Do not return anything, modify matrix in-place instead.\r\n */\r\nvar rotate = function(matrix) {\r\n    DeetCode.array(\"matrix\", matrix);\r\n    matrix.reverse();\r\n    DeetCode.array(\"matrix\", matrix);\r\n    for (let i = 0; i < matrix.length; i++) {\r\n        for (let j = i; j < matrix.length; j++) {\r\n            const tmp = matrix[i][j];\r\n            matrix[i][j] = matrix[j][i];\r\n            matrix[j][i] = tmp;\r\n            DeetCode.array(\"matrix\", matrix);\r\n        }\r\n    }\r\n};\r\n\r\nconst input = [[1,2,3],[4,5,6],[7,8,9]];\r\nrotate(input);\r\nconst expect = [[7,4,1],[8,5,2],[9,6,3]];\r\nDeetCode.equal(input, expect);",
      "notes": null,
      "neetcode_notes": "rotate layer-by-layer, use that it's a square as advantage, rotate positions in reverse order, store a in temp, a = b, b = c, c = d, d = temp;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ecb-7b68-8df4-7315a99c6245",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "House Robber II",
      "slug": "house-robber-ii",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/house-robber-ii/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/rWAJCfYYOvM",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar rob = function(nums) {\r\n    DeetCode.array(\"nums\", nums);\r\n    if (nums.length === 1) return nums[0];\r\n    function rob1(nums) {\r\n        const dp = new Array(nums.length);\r\n        for (let i = 0; i < nums.length; i++) {\r\n            if (i === 0) {\r\n                dp[i] = nums[i];\r\n            } else if (i === 1) {\r\n                dp[i] = Math.max(nums[i], dp[i-1]);\r\n            } else {\r\n                dp[i] = Math.max(nums[i] + dp[i-2], dp[i-1]);\r\n            }\r\n        }\r\n        return dp[dp.length-1];\r\n    }\r\n    const a = rob1(nums.slice(0, nums.length - 1));\r\n    const b = rob1(nums.slice(1));\r\n    return Math.max(a, b);\r\n};\r\n\r\nconst res = rob([1,2,3,1]);\r\nDeetCode.equal(res, 4);",
      "notes": null,
      "neetcode_notes": "subarr = arr without first & last, get max of subarr, then pick which of first/last should be added to it",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ecd-71bb-a1bd-ab019730c2ed",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Group Anagrams",
      "slug": "group-anagrams",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/group-anagrams/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/vzdNOK2oB2E",
      "solution": "/**\r\n * @param {string[]} strs\r\n * @return {string[][]}\r\n */\r\nvar groupAnagrams = function(strs) {\r\n    const map = new Map();\r\n\r\n    for (const str of strs) {\r\n        const key = str.split(\"\").sort().join(\"\");\r\n        if (!map.has(key)) {\r\n            map.set(key, []);\r\n        }\r\n        const arr = map.get(key);\r\n        arr.push(str);\r\n        DeetCode.map(\"map\", map);\r\n    }\r\n\r\n    return [...map.values()];\r\n};\r\n\r\nconst res = groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]);\r\nDeetCode.equal(res, [[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]);",
      "notes": null,
      "neetcode_notes": "for each of 26 chars, use count of each char in each word as tuple for key in dict, value is the list of anagrams;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ed0-764e-8d94-c44771665fb5",
      "category_id": "018fe6e3-6c04-79eb-997b-3153f285556f",
      "name": "Merge Intervals",
      "slug": "merge-intervals",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/merge-intervals/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/44H3cEC2fFM",
      "solution": "/**\r\n * @param {number[][]} intervals\r\n * @return {number[][]}\r\n */\r\nvar merge = function(intervals) {\r\n    intervals.sort((a, b) => a[0] - b[0]);\r\n    DeetCode.array(\"intervals\", intervals);    \r\n    const res = [intervals[0]];\r\n    DeetCode.array(\"res\", res);\r\n    for (let i = 1; i < intervals.length; i++) {\r\n        const b = intervals[i];\r\n        const a = res[res.length - 1];\r\n        if (a[1] >= b[0]) {\r\n            const start = Math.min(a[0], b[0]);\r\n            const end = Math.max(a[1], b[1]);\r\n            res[res.length - 1] = [start, end];\r\n        } else {\r\n            res.push(b);\r\n        }\r\n        DeetCode.array(\"res\", res);\r\n    }\r\n    return res;\r\n};\r\n\r\nconst intervals = [[1,3],[2,6],[8,10],[15,18]];\r\nDeetCode.array(\"intervals\", intervals);\r\nconst res = merge(intervals);\r\nDeetCode.equal(res, [[1,6],[8,10],[15,18]]);",
      "notes": null,
      "neetcode_notes": "sort each interval, overlapping intervals should be adjacent, iterate and build solution; also graph method, less efficient, more complicated",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ed2-7110-81bd-a4c13c40c91a",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Decode Ways",
      "slug": "decode-ways",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/decode-ways/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/6aEyTjOwlJU",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar numDecodings = function(s) {\r\n    const memo = new Map();\r\n    function dfs(i) {\r\n        if (i > s.length - 1) {\r\n            return 1;\r\n        }\r\n        if (memo.has(i)) {\r\n            return memo.get(i);\r\n        }\r\n        let res = 0;\r\n        if (s[i] !== \"0\") {\r\n            res += dfs(i+1);\r\n        }\r\n        if (i < s.length - 1) {\r\n            if (s[i] === \"1\" || (s[i] === \"2\" && s[i+1] <= \"6\")) {\r\n                res += dfs(i+2);\r\n            }\r\n        }\r\n        DeetCode.string(\"s\", s, {pointers: {i}})\r\n        memo.set(i, res);\r\n        return res;\r\n    }\r\n    return dfs(0);\r\n};\r\n\r\nconst res = numDecodings(\"226\");\r\nDeetCode.equal(res, 3);\r\n\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar numDecodings = function(s) {\r\n    const n = s.length + 1;\r\n    const dp = new Array(n).fill(0);\r\n    dp[0] = 1;\r\n    if (s[0] === \"0\") {\r\n        dp[1] = 0;\r\n    } else {\r\n        dp[1] = 1;\r\n    }\r\n    for (let i = 2; i < n; i++) {\r\n        if (s[i-1] !== \"0\") {\r\n            dp[i] += dp[i-1];\r\n        }\r\n        if (s[i-2] === \"1\" || (s[i-2] === \"2\" && s[i-1] <= \"6\")) {\r\n            dp[i] += dp[i-2];\r\n        }\r\n    }\r\n    return dp[dp.length - 1];\r\n};\r\n\r\n\r\nconst res2 = numDecodings(\"226\");\r\nDeetCode.equal(res2, 3);",
      "notes": null,
      "neetcode_notes": "can cur char be decoded in one or two ways? Recursion -> cache -> iterative dp solution, a lot of edge cases to determine, 52, 31, 29, 10, 20 only decoded one way, 11, 26 decoded two ways",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ed4-7531-bb54-9d465ef01e19",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Pacific Atlantic Water Flow",
      "slug": "pacific-atlantic-water-flow",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/s-VkcjHqkGI",
      "solution": "/**\r\n * @param {number[][]} heights\r\n * @return {number[][]}\r\n */\r\nvar pacificAtlantic = function(heights) {\r\n    const n = heights.length;\r\n    const m = heights[0].length;\r\n    const pac = new Array(n).fill()\r\n        .map(() => new Array(m).fill(false));\r\n\r\n    const atl = new Array(n).fill()\r\n        .map(() => new Array(m).fill(false));\r\n\r\n    DeetCode.array(\"pac\", pac);\r\n    DeetCode.array(\"atl\", atl);\r\n\r\n    // search top\r\n    for (let j = 0; j < m; j++) {\r\n        dfs(0, j, pac, heights[0][j]);\r\n    }\r\n\r\n    // search left\r\n    for (let i = 0; i < n; i++) {\r\n        dfs(i, 0, pac, heights[i][0]);\r\n    }\r\n\r\n    // search bottom\r\n    for (let j = 0; j < m; j++) {\r\n        dfs(n - 1, j, atl, heights[n-1][j]);\r\n    }\r\n\r\n    // search right\r\n    for (let i = 0; i < n; i++) {\r\n        dfs(i, m-1, atl, heights[i][m-1]);\r\n    }\r\n\r\n    const res = [];\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < m; j++) {\r\n            if (pac[i][j] && atl[i][j]) {\r\n                res.push([i, j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return res;\r\n\r\n    function dfs(i, j, seen, prevHeight) {\r\n        if (i < 0 || j < 0 || i > n - 1 || j > m - 1) {\r\n            return;\r\n        }\r\n        if (seen[i][j]) {\r\n            return;\r\n        }\r\n        if (heights[i][j] < prevHeight) {\r\n            return;\r\n        }\r\n        seen[i][j] = true;\r\n\r\n        DeetCode.array(\"pac\", pac);\r\n        DeetCode.array(\"atl\", atl);\r\n\r\n        dfs(i+1, j, seen, heights[i][j]);\r\n        dfs(i-1, j, seen, heights[i][j]);\r\n        dfs(i, j+1, seen, heights[i][j]);\r\n        dfs(i, j-1, seen, heights[i][j]);\r\n    }\r\n};\r\n\r\nconst heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]];\r\nconst res = pacificAtlantic(heights);\r\nDeetCode.equal(res, [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]);",
      "notes": null,
      "neetcode_notes": "dfs each cell, keep track of visited, and track which reach pac, atl; dfs on cells adjacent to pac, atl, find overlap of cells that are visited by both pac and atl cells;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ed6-7705-82b4-af20c1146005",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Jump Game",
      "slug": "jump-game",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/jump-game/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/Yan0cv2cLy8",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nvar canJump = function(nums) {\r\n    const dp = new Array(nums.length).fill(false);\r\n    dp[nums.length - 1] = true;\r\n    DeetCode.array(\"dp\", dp);\r\n    for (let i = nums.length - 2; i >= 0; i--) {\r\n        const jump = nums[i];\r\n        for (let j = 1; j < jump+1; j++) {\r\n            dp[i] = dp[i + j];\r\n            DeetCode.array(\"dp\", dp, {pointers: {i, \"i+j\": i+j}});\r\n            if (dp[i]) break;\r\n        }\r\n    }\r\n    return dp[0];\r\n};\r\n\r\nconst res = canJump([2,3,1,1,4]);\r\nDeetCode.equal(res, true);\r\n\r\n// const res = canJump([2,5,0,0]);\r\n// DeetCode.equal(res, true);",
      "notes": null,
      "neetcode_notes": "visualize the recursive tree, cache solution for O(n) time/mem complexity, iterative is O(1) mem, just iterate backwards to see if element can reach goal node, if yes, then set it equal to goal node, continue;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ed8-7505-8764-11d6a3a8cd61",
      "category_id": "018fe6e3-6c01-7c9d-8225-5802bc33ef41",
      "name": "Set Matrix Zeroes",
      "slug": "set-matrix-zeroes",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/set-matrix-zeroes/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/T41rL0L3Pnw",
      "solution": "/**\r\n * @param {number[][]} matrix\r\n * @return {void} Do not return anything, modify matrix in-place instead.\r\n */\r\nvar setZeroes = function(matrix) {\r\n    DeetCode.array(\"matrix\", matrix);\r\n    for (let i = 0; i < matrix.length; i++) {\r\n        for (let j = 0; j < matrix[0].length; j++) {\r\n            if (matrix[i][j] === 0) {\r\n                matrix[i][j] = \".\";\r\n                DeetCode.array(\"matrix\", matrix);\r\n                update(i, j);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < matrix.length; i++) {\r\n        for (let j = 0; j < matrix[0].length; j++) {\r\n            if (matrix[i][j] === \".\") {\r\n                matrix[i][j] = 0;\r\n                DeetCode.array(\"matrix\", matrix);\r\n            } \r\n        }\r\n    }\r\n\r\n    function update(r, c) {\r\n        for (let i = 0; i < matrix.length; i++) {\r\n            if (matrix[i][c] !== 0)\r\n                matrix[i][c] = \".\";\r\n                DeetCode.array(\"matrix\", matrix);\r\n        }\r\n        for (let i = 0; i < matrix[0].length; i++) {\r\n            if (matrix[r][i] !== 0)\r\n                matrix[r][i] = \".\";\r\n                DeetCode.array(\"matrix\", matrix);\r\n        }\r\n    }\r\n};\r\n\r\nconst matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]];\r\nsetZeroes(matrix);\r\nconst expect = [[0,0,0,0],[0,4,5,0],[0,3,1,0]];\r\nDeetCode.equal(matrix, expect);",
      "notes": null,
      "neetcode_notes": "use sets to keep track of all rows, cols to zero out, after, for each num if it is in a zero row or col then change it to 0; flag first cell in row, and col to mark row/col that needs to be zeroed;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eda-74f1-af18-cf878023fe5f",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Word Break Problem",
      "slug": "word-break",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/word-break/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/Sx9NNgInc3A",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {string} s\r\n * @param {string[]} wordDict\r\n * @return {boolean}\r\n */\r\nvar wordBreak = function(s, wordDict) {\r\n    const memo = new Map();\r\n    function dfs(i) {\r\n        DeetCode.string(\"s\", s, { pointers: {i}});\r\n        if (i > s.length - 1) {\r\n            return true;\r\n        }\r\n        if (memo.has(i)) {\r\n            return memo.get(i);\r\n        }\r\n        for (const word of wordDict) {\r\n            if (s.slice(i, i+word.length) === word) {\r\n                const res = dfs(i+word.length);\r\n                memo.set(i+word.length, res);\r\n                if (res) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    return dfs(0);\r\n};\r\n\r\nconst res = wordBreak(\"leetcode\", [\"leet\", \"code\"]);\r\nDeetCode.equal(res, true);",
      "notes": null,
      "neetcode_notes": "for each prefix, if prefix is in dict and wordbreak(remaining str)=True, then return True, cache result of wordbreak;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5edc-72b9-a552-81213fa41224",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Number of Connected Components in an Undirected Graph (Leetcode Premium)",
      "slug": "number-of-connected-components-in-an-undirected-graph",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/8f1XPm4WOUc",
      "solution": null,
      "notes": null,
      "neetcode_notes": "dfs on each node that hasn’t been visited, increment component count, adjacency list; bfs and union find are possible;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ede-7022-811f-22bc2a42c26b",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Longest Common Subsequence",
      "slug": "longest-common-subsequence",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/longest-common-subsequence/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/Ua0GhsJSlWM",
      "solution": "/**\r\n * @param {string} text1\r\n * @param {string} text2\r\n * @return {number}\r\n */\r\nvar longestCommonSubsequence = function(text1, text2) {\r\n    const dp = new Array(text1.length+1).fill().map(() => new Array(text2.length+1).fill(0));\r\n    DeetCode.array(\"dp\", dp);\r\n    for (let i = 1; i < dp.length; i++) {\r\n        for (let j = 1; j < dp[0].length; j++) {\r\n            if (text1[i-1] === text2[j-1]) {\r\n                dp[i][j] = dp[i-1][j-1] + 1;\r\n            } else {\r\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\r\n            }\r\n            DeetCode.array(\"dp\", dp);\r\n        }\r\n    }\r\n    return dp[dp.length-1][dp[0].length-1];\r\n};\r\n\r\nconst text1 = \"abcde\";\r\nconst text2 = \"ace\";\r\nconst res = longestCommonSubsequence(text1, text2);\r\nDeetCode.equal(res, 3);",
      "notes": null,
      "neetcode_notes": "recursive: if first chars are equal find lcs of remaining of each, else max of: lcs of first and remain of 2nd and lcs of 2nd remain of first, cache result; nested forloop to compute the cache without recursion;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ee1-7998-82a3-60c1e96dfa7f",
      "category_id": "018fe6e3-6c01-7c9d-8225-5802bc33ef41",
      "name": "Word Search",
      "slug": "word-search",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/word-search/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/pfiQ_PS1g8E",
      "solution": "/**\r\n * @param {character[][]} board\r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nvar exist = function(board, word) {\r\n    const visited = new Array(board.length).fill().map(() => new Array(board[0].length));\r\n    DeetCode.array(\"board\", board);\r\n    DeetCode.array(\"visited\", visited);\r\n    DeetCode.string(\"word\", word);\r\n    function dfs(i, j, index) {\r\n        if (i < 0 || i > board.length - 1 || j < 0 || j > board[0].length - 1) {\r\n            return false;\r\n        }\r\n\r\n        if (visited[i][j] === true) {\r\n            return false;\r\n        }\r\n\r\n        if (board[i][j] != word[index]) {\r\n            return false;\r\n        }\r\n\r\n        DeetCode.string(\"word\", word, { pointers: {index}});\r\n\r\n        if (index === word.length - 1) {\r\n            return true;\r\n        }\r\n\r\n        visited[i][j] = true;\r\n        DeetCode.array(\"visited\", visited);\r\n\r\n        const a = dfs(i+1, j, index+1);\r\n        const b = dfs(i-1, j, index+1);\r\n        const c = dfs(i, j-1, index+1);\r\n        const d = dfs(i, j+1, index+1);\r\n        visited[i][j] = false;\r\n        return a || b || c || d;\r\n    }\r\n\r\n    for (let i = 0; i < board.length; i++) {\r\n        for (let j = 0; j < board[0].length; j++) {\r\n            const res = dfs(i,j,0);\r\n            if (res) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nconst board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]];\r\nconst word = \"ABCCED\";\r\nconst res = exist(board, word);\r\nDeetCode.equal(res, true);",
      "notes": null,
      "neetcode_notes": "dfs on each cell, for each search remember visited cells, and remove cur visited cell right before you return from dfs;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ee3-7d2e-9829-ae84dde50671",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Validate Binary Search Tree",
      "slug": "validate-binary-search-tree",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/validate-binary-search-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/s6ATEkipzow",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar isValidBST = function(root) {\r\n    DeetCode.tree(\"input\", input);\r\n    function dfs(node, min, max) {\r\n        if (!node) {\r\n            return true;\r\n        }\r\n        node.color = \"green\";\r\n        DeetCode.tree(\"input\", input);\r\n        if (node.val >= max) {\r\n            return false;\r\n        }\r\n        if (node.val <= min) {\r\n            return false;\r\n        }\r\n        const l = dfs(node.left, min, node.val);\r\n        const r = dfs(node.right, node.val, max);\r\n        return l && r;\r\n    }\r\n    return dfs(root, -Infinity, Infinity);\r\n};\r\n\r\nconst input = DeetCode.arrayToBinaryTree([5,1,4,null,null,3,6]);\r\nconst res = isValidBST(input);\r\nDeetCode.equal(res, false);",
      "notes": null,
      "neetcode_notes": "trick is use built in python min/max values float(\"inf\"), \"-inf\", as parameters; iterative in-order traversal, check each val is greater than prev;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ee6-7b3b-b4aa-5f48e85e735f",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Add and Search Word",
      "slug": "add-and-search-word-data-structure-design",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/add-and-search-word-data-structure-design/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/BTf05gs_8iU",
      "solution": "const TrieNode = function() {\r\n    this.children = {};\r\n    this.isWord = false;\r\n}\r\n\r\nvar WordDictionary = function() {\r\n    this.root = new TrieNode();\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {void}\r\n */\r\nWordDictionary.prototype.addWord = function(word) {\r\n    let cur = this.root;\r\n    for (const char of word) {\r\n        const node = cur.children[char] || new TrieNode();\r\n        cur.children[char] = node;\r\n        cur = node;\r\n    }\r\n    cur.isWord = true;\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nWordDictionary.prototype.search = function(word) {\r\n    function dfs(word, node, i) {\r\n        node.color = \"green\";\r\n        DeetCode.trie(\"obj\", obj);\r\n        if (!node) return false;\r\n        if (i === word.length) return node.isWord;\r\n        if (word[i] === \".\") {\r\n            for (const char of Object.keys(node.children)) {\r\n                const child = node.children[char];\r\n                const hasWord = dfs(word, child, i+1);\r\n                if (hasWord) return true;\r\n            }\r\n            return false;\r\n        }\r\n        return dfs(word, node.children[word[i]], i+1);\r\n    }\r\n\r\n    return dfs(word, this.root, 0);\r\n};\r\n\r\n/** \r\n * Your WordDictionary object will be instantiated and called as such:\r\n * var obj = new WordDictionary()\r\n * obj.addWord(word)\r\n * var param_2 = obj.search(word)\r\n */\r\n\r\nconst obj = new WordDictionary();\r\nDeetCode.trie(\"obj\", obj);\r\nobj.addWord(\"bad\");\r\nDeetCode.trie(\"obj\", obj);\r\nobj.addWord(\"mad\");\r\nDeetCode.trie(\"obj\", obj);\r\nobj.addWord(\"bat\");\r\nDeetCode.trie(\"obj\", obj);\r\nconst res = obj.search(\"b.t\");\r\nDeetCode.trie(\"obj\", obj);\r\nDeetCode.equal(res, true);",
      "notes": null,
      "neetcode_notes": "if char = \".\" run search for remaining portion of word on all of curr nodes children;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ee8-7e40-a872-887350e76c1b",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Longest Palindromic Substring",
      "slug": "longest-palindromic-substring",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/longest-palindromic-substring/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/XYQecbcd6_c",
      "solution": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar longestPalindrome = function(s) {\r\n    const n = s.length;\r\n    const dp = new Array();\r\n    let left = 0;\r\n    let right = 1;\r\n    let max = 0;\r\n    for (let i = 0; i < n; i++) {\r\n        dp.push(new Array(n));\r\n    }\r\n    DeetCode.array(\"dp\", dp);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        for (let j = i; j < n; j++) {\r\n            DeetCode.array(\"dp\", dp);\r\n            if (i === j) {\r\n                dp[i][j] = true;\r\n                continue;\r\n            }\r\n            if (s[i] == s[j]) {\r\n                if (j - i + 1 === 2) {\r\n                    dp[i][j] = true;\r\n                } else {\r\n                    dp[i][j] = dp[i + 1][j - 1];\r\n                }\r\n                \r\n                if (dp[i][j] && (j - i + 1) > max) {\r\n                    max = j - i + 1;\r\n                    left = i;\r\n                    right = j + 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return s.substring(left, right);\r\n};\r\n\r\nconst res = longestPalindrome(\"babad\");\r\nDeetCode.equal(res, \"aba\");",
      "notes": null,
      "neetcode_notes": "foreach char in str, consider it were the middle, consider if pali was odd or even;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eea-7bca-baf0-b06216b16a2e",
      "category_id": "018fe6e3-6c04-79eb-997b-3153f285556f",
      "name": "Meeting Rooms II (Leetcode Premium)",
      "slug": "meeting-rooms-ii",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/meeting-rooms-ii/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/FdzJmTCVyJU",
      "solution": null,
      "notes": null,
      "neetcode_notes": "we care about the points in time where we are starting/ending a meeting, we already are given those, just separate start/end and traverse counting num of meetings going at these points in time; for each meeting check if a prev meeting has finished before curr started, using min heap;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eec-7119-9a0a-b696f0b28e91",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Product of Array Except Self",
      "slug": "product-of-array-except-self",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/product-of-array-except-self/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/bNvIQI2wAjk",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nvar productExceptSelf = function(nums) {\r\n    const a = new Array(nums.length);\r\n    a[nums.length - 1] = 1;\r\n    for (let i = nums.length - 2; i >= 0; i--) {\r\n        a[i] = nums[i + 1] * a[i + 1];\r\n    }\r\n\r\n    const b = new Array(nums.length);\r\n    b[0] = 1;\r\n    for (let i = 1; i < nums.length; i++) {\r\n        b[i] = nums[i - 1] * b[i - 1];\r\n    }\r\n\r\n    const res = new Array(nums.length);\r\n    for (let i = 0; i < nums.length; i++) {\r\n        res[i] = a[i] * b[i];\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\nconst res = productExceptSelf([1,2,3,4]);\r\nDeetCode.equal(res, [24,12,8,6]);",
      "notes": null,
      "neetcode_notes": "make two passes, first in-order, second in-reverse, to compute products",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5eee-7daf-8669-839496a17f74",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Palindromic Substrings",
      "slug": "palindromic-substrings",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/palindromic-substrings/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/4RACzI5-du8",
      "solution": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar countSubstrings = function(s) {\r\n    let res = 0;\r\n    for (let i = 0; i < s.length; i++) {\r\n        res += countPali(i, i, s);\r\n        res += countPali(i, i+1, s);\r\n    }\r\n    return res;\r\n};\r\n\r\nvar countPali = function (l, r, s) {\r\n    DeetCode.string(\"s\", s, {pointers: {l, r}});\r\n    let res = 0;\r\n    while (l >= 0 && r < s.length && s[l] === s[r]) {\r\n        l--;\r\n        r++;\r\n        res++;\r\n        DeetCode.string(\"s\", s, {pointers: {l, r}});\r\n    }\r\n    return res;\r\n}\r\n\r\nconst res = countSubstrings(\"aaa\");\r\nDeetCode.equal(res, 6);",
      "notes": null,
      "neetcode_notes": "same as longest palindromic string, each char in str as middle and expand outwards, do same for pali of even len; maybe read up on manachers alg",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ef0-7184-92e2-534bab124145",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Graph Valid Tree (Leetcode Premium)",
      "slug": "graph-valid-tree",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/graph-valid-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/bXsUuownnoQ",
      "solution": null,
      "notes": null,
      "neetcode_notes": "union find, if union return false, loop exists, at end size must equal n, or its not connected; dfs to get size and check for loop, since each edge is double, before dfs on neighbor of N, remove N from neighbor list of neighbor;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ef2-7923-81a2-a38849856f7b",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Clone Graph",
      "slug": "clone-graph",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/clone-graph/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/mQeF6bN8hMk",
      "solution": "/**\r\n * // Definition for a Node.\r\n * function _Node(val, neighbors) {\r\n *    this.val = val === undefined ? 0 : val;\r\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\r\n * };\r\n */\r\n\r\n/**\r\n * @param {_Node} node\r\n * @return {_Node}\r\n */\r\nvar cloneGraph = function(node) {\r\n    const map = new Map();\r\n    function dfs(node) {\r\n        if (!node) return;\r\n        node.color = \"green\";\r\n        DeetCode.graph(\"root\", root);\r\n        if (map.has(node.val)) {\r\n            return map.get(node.val)\r\n        };\r\n        const newNode = new _Node(node.val);\r\n        map.set(node.val, newNode);\r\n        for (const neighbor of node.neighbors) {\r\n            newNode.neighbors.push(dfs(neighbor))\r\n        }\r\n        return newNode;\r\n    }\r\n    return dfs(node);\r\n};\r\n\r\nconst adjList = [[2,4],[1,3],[2,4],[1,3]];\r\nconsole.log(adjList)\r\nconst nodes = DeetCode.buildGraph(adjList);\r\nconsole.log(nodes)\r\nconst root = nodes[0];\r\nconsole.log(root)\r\nDeetCode.graph(\"root\", root);\r\nconst clone = cloneGraph(root);\r\nconsole.log(clone);",
      "notes": null,
      "neetcode_notes": "recursive dfs, hashmap for visited nodes",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ef4-7f00-b1f6-ed595d82f990",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Search in Rotated Sorted Array",
      "slug": "search-in-rotated-sorted-array",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/U8XENwh8Oy8",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar search = function(nums, target) {\r\n    let l = 0;\r\n    let r = nums.length - 1;\r\n    DeetCode.array(\"nums\", nums, {pointers: {l, r}});\r\n    while (l <= r) {\r\n        const mid = Math.floor((l + r) / 2);\r\n        DeetCode.array(\"nums\", nums, {pointers: {l, r, mid}});\r\n        if (target === nums[mid]) {\r\n            DeetCode.array(\"nums\", nums, {pointers: {l, r}});\r\n            return mid;\r\n        }\r\n        // in the left part\r\n        if (nums[mid] >= nums[l]) {\r\n            if (target >= nums[l] && target < nums[mid]) {\r\n                r = mid - 1;\r\n            } else {\r\n                l = mid + 1;\r\n            }\r\n        // in the right part\r\n        } else {\r\n            if (target > nums[mid] && target <= nums[r]) {\r\n                l = mid + 1;\r\n            } else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return -1;\r\n};\r\n\r\nconst res = search([4,5,6,7,0,1,2], 0);\r\nDeetCode.equal(res, 4);",
      "notes": null,
      "neetcode_notes": "at most two sorted halfs, mid will be apart of left sorted or right sorted, if target is in range of sorted portion then search it, otherwise search other half",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ef5-7e46-90d6-fe8ef57677ec",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Longest Repeating Character Replacement",
      "slug": "longest-repeating-character-replacement",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/longest-repeating-character-replacement/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/gqXU1UyA8pk",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar characterReplacement = function(s, k) {\r\n    let l = 0;\r\n    let r = 0;\r\n    const map = new Map();\r\n    let maxf = 0;\r\n    DeetCode.string(\"s\", s, {pointers: {l, r}});\r\n    while (r < s.length) {\r\n        const count = map.get(s[r]) || 0;\r\n        map.set(s[r], count + 1);\r\n        maxf = Math.max(maxf, count + 1);\r\n        if ((r - l + 1) - maxf > k) {\r\n            map.set(s[l], map.get(s[l]) - 1);\r\n            l++\r\n        }\r\n        r++\r\n        DeetCode.string(\"s\", s, {pointers: {l, r}});\r\n    }\r\n    return r - l;\r\n};\r\n\r\nconst res = characterReplacement(\"AABABBA\", 1);\r\nDeetCode.equal(res, 4);",
      "notes": null,
      "neetcode_notes": "PAY ATTENTION: limited to chars A-Z; for each capital char, check if it could create the longest repeating substr, use sliding window to optimize; check if windowlen=1 works, if yes, increment len, if not, shift window right;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ef7-7d39-8441-c9abf178df20",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Implement Trie (Prefix Tree)",
      "slug": "implement-trie-prefix-tree",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/implement-trie-prefix-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/oobqoCJlHA0",
      "solution": "const TrieNode = function() {\r\n    this.children = {};\r\n    this.isWord = false;\r\n}\r\n\r\nvar Trie = function() {\r\n    this.root = new TrieNode();\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {void}\r\n */\r\nTrie.prototype.insert = function(word) {\r\n    let cur = this.root;\r\n    for (const char of word) {\r\n        const node = cur.children[char] || new TrieNode();\r\n        cur.children[char] = node;\r\n        cur = node;\r\n        DeetCode.trie(\"obj\", obj);\r\n    }\r\n    cur.isWord = true;\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nTrie.prototype.search = function(word) {\r\n    let cur = this.root;\r\n    for (const char of word) {\r\n        if (!cur.children[char]) {\r\n            return false;\r\n        }\r\n        cur = cur.children[char];\r\n        cur.color = \"green\";\r\n        DeetCode.trie(\"obj\", obj);\r\n    }\r\n    return cur.isWord;\r\n};\r\n\r\n/** \r\n * @param {string} prefix\r\n * @return {boolean}\r\n */\r\nTrie.prototype.startsWith = function(prefix) {\r\n    let cur = this.root;\r\n    for (const char of prefix) {\r\n        const node = cur.children[char];\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        cur = node;\r\n        cur.color = \"red\";\r\n        DeetCode.trie(\"obj\", obj);\r\n    }\r\n    return true;\r\n};\r\n\r\n/** \r\n * Your Trie object will be instantiated and called as such:\r\n * var obj = new Trie()\r\n * obj.insert(word)\r\n * var param_2 = obj.search(word)\r\n * var param_3 = obj.startsWith(prefix)\r\n */\r\n\r\nvar obj = new Trie();\r\nDeetCode.trie(\"obj\", obj);\r\nobj.insert(\"apple\");\r\nobj.search(\"apple\");\r\nobj.startsWith(\"app\");",
      "notes": null,
      "neetcode_notes": "node has children characters, and bool if its an ending character, node DOESN’T have or need char, since root node doesn’t have a char, only children;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5ef9-7ecc-a33d-8af2cc3f73c2",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Maximum Product Subarray",
      "slug": "maximum-product-subarray",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/maximum-product-subarray/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/lXVy6YWFcRM",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxProduct = function(nums) {\r\n    DeetCode.array(\"nums\", nums);\r\n    let res = nums[0];\r\n    let min = new Array(nums.length);\r\n    let max = new Array(nums.length);\r\n    min[0] = nums[0];\r\n    max[0] = nums[0];\r\n    DeetCode.array(\"min\", min);\r\n    DeetCode.array(\"max\", max);\r\n    for (let i = 1; i < nums.length; i++) {\r\n        const a = min[i-1] * nums[i];\r\n        const b = max[i-1] * nums[i];\r\n        min[i] = Math.min(nums[i], a, b);\r\n        max[i] = Math.max(nums[i], a, b);\r\n        res = Math.max(res, max[i]);\r\n        DeetCode.array(\"min\", min, {pointers: {i}});\r\n        DeetCode.array(\"max\", max, {pointers: {i}});\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\nconst res = maxProduct([2,3,-2,4]);\r\nDeetCode.equal(res, 6);",
      "notes": null,
      "neetcode_notes": "dp: compute max and max-abs-val for each prefix subarr;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5efb-7946-bb00-c6a1b5de7efc",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Find Minimum in Rotated Sorted Array",
      "slug": "find-minimum-in-rotated-sorted-array",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/nIVW4P8b1VA",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar findMin = function(nums) {\r\n    let l = 0;\r\n    let r = nums.length - 1;\r\n    DeetCode.array(\"nums\", nums, {pointers: {l, r}});\r\n    while (l < r) {\r\n        let mid = Math.floor((l + r) / 2);\r\n        DeetCode.array(\"nums\", nums, {pointers: {l, r, mid}});\r\n        if (nums[r] < nums[mid]) {\r\n            l = mid + 1;\r\n        } else if (nums[r] > nums[mid]) {\r\n            r = mid;\r\n        } else if (nums[l] > nums[mid]) {\r\n            l = mid;\r\n        } else if (nums[l] < nums[mid]) {\r\n            l = mid;\r\n        }\r\n    }\r\n    DeetCode.array(\"nums\", nums, {pointers: {l, r}});\r\n    return nums[l];\r\n};\r\n\r\nconst res = findMin([4,5,6,7,0,1,2])\r\nDeetCode.equal(res, 0);",
      "notes": null,
      "neetcode_notes": "check if half of array is sorted in order to find pivot, arr is guaranteed to be in at most two sorted subarrays",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5efc-7755-bdac-98ca68e80446",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "3Sum",
      "slug": "3sum",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/3sum/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/jzZsG8n2R9A",
      "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nvar threeSum = function(nums) {\r\n  nums.sort((a,b) => a-b)\r\n  var res = []\r\n  for (var i = 0; i < nums.length; i++) {\r\n    if (nums[i] > 0) {\r\n        break;\r\n    }\r\n    if (i === 0 || nums[i-1] !== nums[i]) {\r\n      twoSumII(nums, i, res)\r\n    }\r\n  }\r\n  \r\n  function twoSumII(nums, i, res) {\r\n    var l = i+1\r\n    var r = nums.length - 1\r\n    DeetCode.array(\"nums\", nums, {pointers: {l, r, i}});\r\n    while (l < r) {\r\n      var sum = nums[i] + nums[l] + nums[r]\r\n      if (sum < 0 || (l > i + 1 && nums[l] === nums[l-1])) {\r\n        l++\r\n      } else if (sum > 0 || (r < nums.length-1 && nums[r] === nums[r+1])) {\r\n        r--\r\n      } else {\r\n        res.push([nums[i], nums[l++], nums[r--]])\r\n        DeetCode.array(\"res\", res);\r\n      }\r\n      DeetCode.array(\"nums\", nums, {pointers: {l, r, i}});\r\n    }\r\n  }\r\n  \r\n  return res\r\n}\r\n\r\nconst res = threeSum([-1,0,1,2,-1,-4]);\r\nDeetCode.equal(res, [[-1,-1,2],[-1,0,1]]);",
      "notes": null,
      "neetcode_notes": "sort input, for each first element, find next two where -a = b+c, if a=prevA, skip a, if b=prevB skip b to elim duplicates; to find b,c use two pointers, left/right on remaining list;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5efe-7160-afed-21f50fa25019",
      "category_id": "018fe6e3-6bdd-7575-89fe-a18ebfad9a68",
      "name": "Counting Bits",
      "slug": "counting-bits",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/counting-bits/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/RyBM56RIWrM",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number} n\r\n * @return {number[]}\r\n */\r\nvar countBits = function(n) {\r\n    const dp = new Array(n+1).fill(0);\r\n    let offset = 1;\r\n    for (let i = 1; i < n+1; i++) {\r\n        if (offset * 2 === i) {\r\n            offset = i;\r\n        }\r\n        dp[i] = 1 + dp[i - offset];\r\n    }\r\n    return dp;\r\n};\r\n\r\nconst res = countBits(5);\r\nDeetCode.equal(res, [0,1,1,2,1,2]);",
      "notes": null,
      "neetcode_notes": "write out result for num=16 to figure out pattern; res[i] = res[i - offset], where offset is the biggest power of 2 <= I;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f01-79c5-8f38-8134d9693d78",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Combination Sum",
      "slug": "combination-sum",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/combination-sum/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/GBKI9VSKdGg",
      "solution": "/**\r\n * @param {number[]} candidates\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nvar combinationSum = function(candidates, target) {\r\n    const res = [];\r\n    DeetCode.array(\"res\", res);\r\n    function dfs(i, arr, total) {\r\n        DeetCode.array(\"arr\", arr);\r\n        if (total === target) {\r\n            res.push([...arr]);\r\n            DeetCode.array(\"res\", res);\r\n            return;\r\n        }\r\n        if (i >= candidates.length) {\r\n            return;\r\n        }\r\n        if (total > target) {\r\n            return;\r\n        }\r\n        arr.push(candidates[i]);\r\n        DeetCode.array(\"arr\", arr);\r\n        dfs(i, arr, total + candidates[i]);\r\n        arr.pop();\r\n        DeetCode.array(\"arr\", arr);\r\n        dfs(i + 1, arr, total);\r\n    }\r\n    dfs(0, [], 0);\r\n    return res;\r\n};\r\n\r\nconst res = combinationSum([2,3,6,7], 7);\r\nDeetCode.equal(res, [[2,2,3],[7]]);",
      "notes": null,
      "neetcode_notes": "visualize the decision tree, base case is curSum = or > target, each candidate can have children of itself or elements to right of it inorder to elim duplicate solutions;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f03-74d3-a2f1-c676664e1e1d",
      "category_id": "018fe6e3-6bfa-731a-8eda-f5924821d196",
      "name": "Remove Nth Node From End Of List",
      "slug": "remove-nth-node-from-end-of-list",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/XVuQxVej6y8",
      "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} n\r\n * @return {ListNode}\r\n */\r\nvar removeNthFromEnd = function(head, n) {\r\n    const dummy = new ListNode();\r\n    dummy.next = head;\r\n    let l = dummy;\r\n    let r = head;\r\n    DeetCode.linkedList(\"dummy\", dummy, {pointers: {dummy, l, r}});\r\n    for (let i = 0; i < n; i++) {\r\n        r = r.next;\r\n        DeetCode.linkedList(\"dummy\", dummy, {pointers: {dummy, l, r}});\r\n    }\r\n    while (r) {\r\n        r = r.next;\r\n        l = l.next;\r\n        DeetCode.linkedList(\"dummy\", dummy, {pointers: {dummy, l, r}});\r\n    }\r\n    l.next = l.next.next;\r\n    DeetCode.linkedList(\"dummy\", dummy, {pointers: {dummy, l, r}});\r\n    return dummy.next;\r\n};\r\n\r\nconst head = DeetCode.arrayToLinkedList([1,2,3,4,5]);\r\nconst res = removeNthFromEnd(head, 2);\r\nDeetCode.equal(DeetCode.linkedListToArray(res), [1,2,3,5]);",
      "notes": null,
      "neetcode_notes": "use dummy node at head of list, compute len of list; two pointers, second has offset of n from first;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f05-7ff8-8b85-a733b009bcda",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Number of Islands",
      "slug": "number-of-islands",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/number-of-islands/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/pV2kpPD66nE",
      "solution": "/**\r\n * @param {character[][]} grid\r\n * @return {number}\r\n */\r\nvar numIslands = function(grid) {\r\n    const n = grid.length;\r\n    const m = grid[0].length;\r\n    let res = 0;\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < m; j++) {\r\n            if (grid[i][j] === \"1\") {\r\n                dfs(i, j)\r\n                res++;\r\n            }\r\n        }\r\n    }\r\n    function dfs(i, j) {\r\n        if (i < 0 || j < 0 || i > n-1 || j > m-1) {\r\n            return;\r\n        }\r\n        DeetCode.array(\"grid\", grid);\r\n        if (grid[i][j] === \"0\") {\r\n            return;\r\n        }\r\n        if (grid[i][j] === \".\") {\r\n            return;\r\n        }\r\n        if (grid[i][j] === \"1\") {\r\n            grid[i][j] = \".\"\r\n            dfs(i+1, j);\r\n            dfs(i-1, j);\r\n            dfs(i, j+1);\r\n            dfs(i, j-1);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n\r\nconst grid = [\r\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\r\n];\r\nconst res = numIslands(grid);\r\nDeetCode.equal(res, 1);",
      "notes": null,
      "neetcode_notes": "foreach cell, if cell is 1 and unvisited run dfs, increment cound and marking each contigous 1 as visited",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f07-7033-9788-db68ba83bf49",
      "category_id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Coin Change",
      "slug": "coin-change",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/coin-change/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/H9bfqozjoqs",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} coins\r\n * @param {number} amount\r\n * @return {number}\r\n */\r\nvar coinChange = function(coins, amount) {\r\n    const dp = new Array(amount+1);\r\n    dp[0] = 0;\r\n    for (let i = 1; i <= amount; i++) {\r\n        let min = Infinity;\r\n        for (const coin of coins) {\r\n            if (i - coin >= 0) {\r\n                min = Math.min(dp[i - coin] + 1, min);\r\n            }\r\n        }\r\n        dp[i] = min;\r\n    }\r\n    return dp[amount] < Infinity ? dp[amount] : -1;\r\n};\r\n\r\nconst res1 = coinChange([1,2,5], 11);\r\nDeetCode.equal(res1, 3);\r\n\r\nconst res2 = coinChange([2], 3);\r\nDeetCode.equal(res2, -1);\r\n\r\nconst res3 = coinChange([1], 0);\r\nDeetCode.equal(res3, 0);",
      "notes": null,
      "neetcode_notes": "top-down: recursive dfs, for amount, branch for each coin, cache to store prev coin_count for each amount; bottom-up: compute coins for amount = 1, up until n, using for each coin (amount - coin), cache prev values",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f09-79e2-95f4-df4eecb58e13",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Encode and Decode Strings (Leetcode Premium)",
      "slug": "encode-and-decode-strings",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/encode-and-decode-strings/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/B1k_sxOSgv8",
      "solution": null,
      "notes": null,
      "neetcode_notes": "store length of str before each string and delimiter like '#';",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f0b-73a1-85d3-b7387902a82e",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Binary Tree Level Order Traversal",
      "slug": "binary-tree-level-order-traversal",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/6ZnyEApgFYg",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nvar levelOrder = function(root) {\r\n    if (!root) return [];\r\n    DeetCode.tree(\"input\", input);\r\n    const q = [root];\r\n    const res = [];\r\n    while (q.length > 0) {\r\n        const level = [];\r\n        const n = q.length; // copy number\r\n        for (let i = 0; i < n; i++) {\r\n            const node = q.shift();\r\n            node.color = \"green\";\r\n            DeetCode.tree(\"input\", input);\r\n            level.push(node.val);\r\n            if (node.left) q.push(node.left);\r\n            if (node.right) q.push(node.right);\r\n        }\r\n        res.push(level);\r\n    }\r\n    return res;\r\n};\r\n\r\nconst input = DeetCode.arrayToBinaryTree([3,9,20,null,null,15,7]);\r\nconst res = levelOrder(input);\r\nDeetCode.equal(res, [[3],[9,20],[15,7]]);",
      "notes": null,
      "neetcode_notes": "iterative bfs, add prev level which doesn't have any nulls to the result;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f0d-745c-b07b-9baf35f450ba",
      "category_id": "018fe6e3-6bfa-731a-8eda-f5924821d196",
      "name": "Reorder List",
      "slug": "reorder-list",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/reorder-list/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/S5bfdUTrKLM",
      "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {void} Do not return anything, modify head in-place instead.\r\n */\r\nvar reorderList = function(head) {\r\n    const mid = getMid(head);\r\n    const reversedFromMid = reverse(mid);\r\n    reorder(head, reversedFromMid);\r\n};\r\n\r\nconst getMid = function(head) {\r\n    let slow = head;\r\n    let fast = head;\r\n    DeetCode.linkedList(\"get mid\", head, {pointers: {slow, fast}});\r\n    while (fast && fast.next) {\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n        DeetCode.linkedList(\"get mid\", head, {pointers: {slow, fast}});\r\n    }\r\n    return slow;\r\n}\r\n\r\nconst reverse = function(head) {\r\n    let prev = null;\r\n    let cur = head;\r\n    let next = null;\r\n    while (cur) {\r\n        next = cur.next;\r\n        cur.next = prev;\r\n        prev = cur;\r\n        cur = next;\r\n    }\r\n    DeetCode.linkedList(\"prev\", prev);\r\n    return prev;\r\n}\r\n\r\nconst reorder = function(l1, l2) {\r\n    let next = null;\r\n    DeetCode.linkedList(\"l1\", l1);\r\n    DeetCode.linkedList(\"l2\", l2);\r\n    DeetCode.linkedList(\"input\", input);\r\n    while (l2.next) {\r\n        next = l1.next;\r\n        l1.next = l2;\r\n        l1 = next;\r\n\r\n        next = l2.next;\r\n        l2.next = l1;\r\n        l2 = next;\r\n        DeetCode.linkedList(\"l1\", l1);\r\n        DeetCode.linkedList(\"l2\", l2);\r\n        DeetCode.linkedList(\"input\", input);\r\n    }\r\n}\r\n\r\nconst input = DeetCode.arrayToLinkedList([1,2,3,4]);\r\nreorderList(input);\r\nDeetCode.equal(DeetCode.linkedListToArray(input), [1,4,2,3]);",
      "notes": null,
      "neetcode_notes": "reverse second half of list, then easily reorder it; non-optimal way is to store list in array;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f10-7603-8437-e484a9599ed6",
      "category_id": "018fe6e3-6c01-7c9d-8225-5802bc33ef41",
      "name": "Spiral Matrix",
      "slug": "spiral-matrix",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/spiral-matrix/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/BJnMZNwUk1M",
      "solution": "/**\r\n * @param {number[][]} matrix\r\n * @return {number[]}\r\n */\r\nvar spiralOrder = function(matrix) {\r\n    DeetCode.array(\"matrix\", matrix);\r\n    let n = matrix.length;\r\n    let m = matrix[0].length;\r\n    let top = 0;\r\n    let left = 0;\r\n    let right = m - 1;\r\n    let bottom = n - 1;\r\n    const res = [];\r\n    DeetCode.array(\"res\", res);\r\n    while (top <= bottom && left <= right) {\r\n        for (let i = left; i <= right; i++) {\r\n            res.push(matrix[top][i]);\r\n            DeetCode.array(\"res\", res);\r\n        }\r\n        top++;\r\n\r\n        for (let i = top; i <= bottom; i++) {\r\n            res.push(matrix[i][right]);\r\n            DeetCode.array(\"res\", res);\r\n        }\r\n        right--;\r\n\r\n        if (top <= bottom) {\r\n            for (let i = right; i >= left; i--) {\r\n                res.push(matrix[bottom][i]);\r\n                DeetCode.array(\"res\", res);\r\n            }\r\n        }\r\n        bottom--;\r\n\r\n        if (left <= right) {\r\n            for (let i = bottom; i >= top; i--) {\r\n                res.push(matrix[i][left]);\r\n                DeetCode.array(\"res\", res);\r\n            }\r\n        }\r\n        left++;\r\n    }\r\n    return res;\r\n};\r\n\r\nconst res = spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]]);\r\nDeetCode.array(\"res\", res);\r\nDeetCode.equal(res, [1,2,3,4,8,12,11,10,9,5,6,7]);",
      "notes": null,
      "neetcode_notes": "keep track of visited cells; keep track of boundaries, layer-by-layer;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f12-7ccb-b93f-5f7a407825d8",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Longest Substring Without Repeating Characters",
      "slug": "longest-substring-without-repeating-characters",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/wiGpQwVHdE0",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLongestSubstring = function(s) {\r\n    let l = 0;\r\n    let r = 0;\r\n    let res = 0;\r\n    const map = new Map();\r\n    while (r < s.length) {\r\n        let count = map.get(s[r]) || 0;\r\n        if (count > 0) {\r\n            map.set(s[l], map.get(s[l]) - 1);\r\n            l++;\r\n        } else {\r\n            map.set(s[r], 1);\r\n            r++;\r\n        }\r\n        res = Math.max(res, r - l);\r\n        DeetCode.string(\"s\", s, {pointers: {l, r}});\r\n    }\r\n    return res;\r\n};\r\n\r\nconst res = lengthOfLongestSubstring(\"pwwkew\");\r\nDeetCode.equal(res, 3);",
      "notes": null,
      "neetcode_notes": "sliding window, if we see same char twice within curr window, shift start position;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f13-79b7-b925-44338dca23ae",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Binary Tree Maximum Path Sum",
      "slug": "binary-tree-maximum-path-sum",
      "difficulty": 3,
      "leetcode_url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/Hr5cWUld4vU",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxPathSum = function(root) {\r\n    DeetCode.tree(\"root\", root);\r\n    let res = -Infinity;\r\n    function dfs(node) {\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        node.color = \"green\";\r\n        DeetCode.tree(\"root\", root);\r\n        const v = node.val;\r\n        const l = dfs(node.left);\r\n        const r = dfs(node.right);\r\n        const max = Math.max(v, v+l, v+r, v+l+r);\r\n        if (max > res || res === undefined) {\r\n            res = max;\r\n        }\r\n        return Math.max(v, v+l, v+r);\r\n    }\r\n    dfs(root);\r\n    return res;\r\n};\r\n\r\nconst res = maxPathSum(DeetCode.arrayToBinaryTree([-10,9,20,null,null,15,7]));\r\nDeetCode.equal(res, 42);",
      "notes": null,
      "neetcode_notes": "helper returns maxpathsum without splitting branches, inside helper we also update maxSum by computing maxpathsum WITH a split;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f15-732c-b65a-29a1a49df1fd",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Serialize and Deserialize Binary Tree",
      "slug": "serialize-and-deserialize-binary-tree",
      "difficulty": 3,
      "leetcode_url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/u4JAi2JJhI8",
      "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar serialize = function(root) {\r\n    DeetCode.tree(\"root\", root);\r\n    const res = [];\r\n    function dfs(node) {\r\n        if (node === null) {\r\n            res.push(null);\r\n            return;\r\n        }\r\n        node.color = \"green\";\r\n        DeetCode.tree(\"root\", root);\r\n        res.push(node.val);\r\n        dfs(node.left);\r\n        dfs(node.right);\r\n    }\r\n    dfs(root);\r\n    return res;\r\n}\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n    function dfs(val) {\r\n        if (val === null) {\r\n            return null;\r\n        }\r\n        const node = new TreeNode(val);\r\n        node.left = dfs(data.shift());\r\n        node.right = dfs(data.shift());\r\n        return node;\r\n    }\r\n    return dfs(data.shift())\r\n}\r\n\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\n\r\nconst input = DeetCode.arrayToBinaryTree([1,2,3,null,null,4,5]);\r\nconst output = deserialize(serialize(input));\r\nDeetCode.tree(\"output\", output);\r\n",
      "notes": null,
      "neetcode_notes": "bfs every single non-null node is added to string, and it's children are added too, even if they're null, deserialize by adding each non-null node to queue, deque node, it's children are next two nodes in string;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f17-7383-8159-7d508f80ba3a",
      "category_id": "018fe6e3-6c03-7e0e-97b3-eec9ced5f80f",
      "name": "Find Median from Data Stream",
      "slug": "find-median-from-data-stream",
      "difficulty": 3,
      "leetcode_url": "https://leetcode.com/problems/find-median-from-data-stream/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/itmhHWaHupI",
      "solution": "DeetCode.enableAutoVis();\r\n\r\nvar MedianFinder = function() {\r\n    this.minpq = new MinPriorityQueue();\r\n    this.maxpq = new MaxPriorityQueue();\r\n};\r\n\r\n/** \r\n * @param {number} num\r\n * @return {void}\r\n */\r\nMedianFinder.prototype.addNum = function(num) {\r\n    this.minpq.enqueue(num);\r\n    this.maxpq.enqueue(this.minpq.dequeue());\r\n    if (this.minpq.size() < this.maxpq.size()) {\r\n        this.minpq.enqueue(this.maxpq.dequeue());\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMedianFinder.prototype.findMedian = function() {\r\n    if (this.minpq.size() > this.maxpq.size()) {\r\n        return this.minpq.front();\r\n    }\r\n    return (this.minpq.front() + this.maxpq.front()) / 2;};\r\n\r\n/** \r\n * Your MedianFinder object will be instantiated and called as such:\r\n * var obj = new MedianFinder()\r\n * obj.addNum(num)\r\n * var param_2 = obj.findMedian()\r\n */\r\n\r\nvar obj = new MedianFinder();\r\nobj.addNum(1);\r\nobj.addNum(2);\r\nobj.addNum(3);\r\nvar res = obj.findMedian();\r\nDeetCode.equal(res, 2);",
      "notes": null,
      "neetcode_notes": "maintain curr median, and all num greater than med in a minHeap, and all num less than med in a maxHeap, after every insertion update median depending on odd/even num of elements;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f19-75b7-a423-c538724916d7",
      "category_id": "018fe6e3-6c04-79eb-997b-3153f285556f",
      "name": "Insert Interval",
      "slug": "insert-interval",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/insert-interval/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/A8NUOmlwOlM",
      "solution": "/**\r\n * @param {number[][]} intervals\r\n * @param {number[]} newInterval\r\n * @return {number[][]}\r\n */\r\nvar insert = function(intervals, newInterval) {\r\n    DeetCode.array(\"intervals\", intervals);\r\n    const res = [];\r\n    for (let i = 0; i < intervals.length; i++) {\r\n        if (newInterval[1] < intervals[i][0]) {\r\n            res.push(newInterval);\r\n            DeetCode.array(\"res\", res);\r\n            return res.concat(intervals.slice(i))\r\n        } else if (newInterval[0] > intervals[i][1]) {\r\n            res.push(intervals[i]);\r\n            DeetCode.array(\"res\", res);\r\n        } else {\r\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])];\r\n        }\r\n        DeetCode.array(\"res\", res);\r\n    }\r\n    res.push(newInterval);\r\n    DeetCode.array(\"res\", res);\r\n    return res;\r\n};\r\n\r\nconst res = insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]);\r\nDeetCode.equal(res, [[1,2],[3,10],[12,16]]);\r\n",
      "notes": null,
      "neetcode_notes": "insert new interval in order, then merge intervals; newinterval could only merge with one interval that comes before it, then add remaining intervals;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f1a-71de-99e5-c518b0ecab15",
      "category_id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Word Search II",
      "slug": "word-search-ii",
      "difficulty": 3,
      "leetcode_url": "https://leetcode.com/problems/word-search-ii/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/asbcE9mZz_U",
      "solution": "class Trie {\r\n    constructor() {\r\n        this.root = new TrieNode();\r\n    }\r\n\r\n    insert(word) {\r\n        let cur = this.root;\r\n        for (const c of word) {\r\n            const child = cur.children[c] || new TrieNode();\r\n            cur.children[c] = child;\r\n            cur = child;\r\n        }\r\n        cur.isWord = true;\r\n    }\r\n}\r\n\r\nclass TrieNode {\r\n    constructor() {\r\n        this.children = {};\r\n        this.isWord = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {character[][]} board\r\n * @param {string[]} words\r\n * @return {string[]}\r\n */\r\nvar findWords = function(board, words) {\r\n    DeetCode.array(\"board\", board);\r\n    const root = new Trie();\r\n    for (const word of words) {\r\n        root.insert(word);\r\n    }\r\n    DeetCode.trie(\"trie\", root);\r\n    const n = board.length;\r\n    const m = board[0].length;\r\n    const res = [];\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < m; j++) {\r\n            const r = dfs(i, j, root.root, \"\");\r\n        }\r\n    }\r\n\r\n    return res;\r\n\r\n    function dfs(i, j, node, word) {\r\n        DeetCode.array(\"board\", board);\r\n        if (i < 0 || j < 0 || i > n-1 || j > m-1) {\r\n            return false;\r\n        }\r\n        const c = board[i][j];\r\n        const child = node.children[c];\r\n        if (child) {\r\n            child.color = \"green\";\r\n            DeetCode.trie(\"trie\", root);\r\n        }\r\n        if (child && child.isWord) {\r\n            res.push(word + c);\r\n            child.isWord = false;\r\n        }\r\n        if (child) {\r\n            board[i][j] = \".\";\r\n            dfs(i+1, j, child, word + c);\r\n            dfs(i-1, j, child, word + c);\r\n            dfs(i, j+1, child, word + c);\r\n            dfs(i, j-1, child, word + c);\r\n            board[i][j] = c;\r\n        }\r\n    }\r\n};\r\n\r\nconst board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]];\r\nconst words = [\"oath\",\"pea\",\"eat\",\"rain\"]\r\nconst res = findWords(board, words);\r\nDeetCode.equal(res, [\"oath\",\"eat\"]);\r\n",
      "notes": null,
      "neetcode_notes": "trick: I though use trie to store the grid, reverse thinking, instead store dictionary words, dfs on each cell, check if cell's char exists as child of root node in trie, if it does, update currNode, and check neighbors, a word could exist multiple times in grid, so don’t add duplicates;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f1c-784a-83a2-4b3cdf8fefb1",
      "category_id": "018fe6e3-6c03-7e0e-97b3-eec9ced5f80f",
      "name": "Merge K Sorted Lists",
      "slug": "merge-k-sorted-lists",
      "difficulty": 3,
      "leetcode_url": "https://leetcode.com/problems/merge-k-sorted-lists/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/q5a5OiGbT6Q",
      "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode[]} lists\r\n * @return {ListNode}\r\n */\r\nvar mergeKLists = function(lists) {\r\n    const dummy = new ListNode();\r\n    DeetCode.linkedList(\"dummy\", dummy);\r\n    const minpq = new MinPriorityQueue((elem) => elem.val);\r\n    DeetCode.minPriorityQueue(\"minpq\", minpq);\r\n    for (const node of lists) {\r\n        let cur = node;\r\n        while (cur) {\r\n            minpq.enqueue(cur);\r\n            DeetCode.minPriorityQueue(\"minpq\", minpq);\r\n            cur = cur.next;\r\n        }\r\n    }\r\n    let cur = dummy;\r\n    while (minpq.size() > 0) {\r\n        const node = minpq.dequeue();\r\n        cur.next = new ListNode(node.val);\r\n        DeetCode.linkedList(\"dummy\", dummy);\r\n        cur = cur.next;\r\n    }\r\n    return dummy.next;\r\n};\r\n\r\nconst lists = [\r\n    DeetCode.arrayToLinkedList([1,4,5]),\r\n    DeetCode.arrayToLinkedList([1,3,4]),\r\n    DeetCode.arrayToLinkedList([2,6])\r\n]\r\nconst res = mergeKLists(lists);\r\nDeetCode.equal(DeetCode.linkedListToArray(res), [1,1,2,3,4,4,5,6]);",
      "notes": null,
      "neetcode_notes": "we always want the min of the current frontier, we can store frontier in heap of size k for efficient pop/push; divide and conquer merging lists;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f1e-7b9b-a21e-cffdd2ced9a0",
      "category_id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "Minimum Window Substring",
      "slug": "minimum-window-substring",
      "difficulty": 3,
      "leetcode_url": "https://leetcode.com/problems/minimum-window-substring/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/jSto0O4AJbM",
      "solution": "/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {string}\r\n */\r\nvar minWindow = function(s, t) {\r\n    if (t === \"\") {\r\n        return \"\";\r\n    }\r\n    DeetCode.string(\"s\", s);\r\n    const countT = new Map();\r\n    DeetCode.map(\"countT\", countT);\r\n    const window = new Map();\r\n    DeetCode.map(\"window\", window);\r\n\r\n    for (const c of t) {\r\n        const count = countT.get(c) || 0;\r\n        countT.set(c, count + 1);\r\n    }\r\n    DeetCode.map(\"countT\", countT);\r\n\r\n    let have = 0;\r\n    const need = countT.size;\r\n\r\n    let res = [-1, -1];\r\n    let resLen = Infinity;\r\n    let l = 0;\r\n    for (let r = 0; r < s.length; r++) {\r\n        DeetCode.string(\"s\", s, {pointers: {l, r}});\r\n        const c = s[r];\r\n        const count = window.get(c) || 0;\r\n        window.set(c, 1 + count);\r\n        DeetCode.map(\"window\", window);\r\n\r\n        if (countT.has(c) && window.get(c) === countT.get(c)) {\r\n            have++;\r\n        }\r\n\r\n        while (have === need) {\r\n            if ((r - l + 1) < resLen) {\r\n                res = [l, r];\r\n                resLen = r - l + 1;\r\n            }\r\n            window.set(s[l], window.get(s[l]) - 1);\r\n            DeetCode.map(\"window\", window);\r\n            if ((countT.has(s[l])) && (window.get(s[l]) < countT.get(s[l]))) {\r\n                have--;\r\n            }\r\n            l++;\r\n            DeetCode.string(\"s\", s, {pointers: {l, r}});\r\n        }\r\n    }\r\n\r\n    l = res[0];\r\n    r = res[1];\r\n\r\n    if (resLen != Infinity) {\r\n        return s.slice(l, r+1)\r\n    } else {\r\n        return \"\";\r\n    }\r\n};\r\n\r\nconst res = minWindow(\"ADOBECODEBANC\", \"ABC\");\r\nDeetCode.equal(res, \"BANC\");",
      "notes": null,
      "neetcode_notes": "need is num of unique char in T, HAVE is num of char we have valid count for, sliding window, move right until valid, if valid, increment left until invalid, to check validity keep track if the count of each unique char is satisfied;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f20-7642-a78a-f955a34c8c94",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Alien Dictionary (Leetcode Premium)",
      "slug": "alien-dictionary",
      "difficulty": 3,
      "leetcode_url": "https://leetcode.com/problems/alien-dictionary/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/6kTZYvNNyps",
      "solution": null,
      "notes": null,
      "neetcode_notes": "chars of a word not in order, the words are in order, find adjacency list of each unique char by iterating through adjacent words and finding first chars that are different, run topsort on graph and do loop detection;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018fe6f3-5f22-7f32-af16-5c1f712068a7",
      "category_id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Longest Consecutive Sequence",
      "slug": "longest-consecutive-sequence",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/longest-consecutive-sequence/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/P6RZZMu_maU",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar longestConsecutive = function(nums) {\r\n    const numSet = new Set();\r\n    let res = 0;\r\n    for (const num of nums) {\r\n        numSet.add(num);\r\n    }\r\n    for (const num of nums) {\r\n        if (numSet.has(num - 1)) {\r\n            continue;\r\n        }\r\n        let cur = num;\r\n        let seq = 0;\r\n        while (numSet.has(cur)) {\r\n            cur = cur + 1;\r\n            seq++;\r\n        }\r\n        res = Math.max(res, seq);\r\n    }\r\n    return res;\r\n};\r\n\r\nconst res = longestConsecutive([100,4,200,1,3,2]);\r\nDeetCode.equal(res, 4);",
      "notes": null,
      "neetcode_notes": "use bruteforce and try to optimize, consider the max subseq containing each num; add each num to hashset, for each num if num-1 doesn’t exist, count the consecutive nums after num, ie num+1; there is also a union-find solution;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018ffc5c-77b9-712a-a2b9-e6bd70081eb1",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Two Sum",
      "slug": "two-sum",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/two-sum/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/KLlXCFG5TnA",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function (nums, target) {\r\n  const map = new Map();\r\n  for (const [index, num] of nums.entries()) {\r\n    DeetCode.array(\"nums\", nums, {pointers: {index}})\r\n    const complement = target - num;\r\n    if (map.has(complement)) {\r\n      return [map.get(complement), index];\r\n    }\r\n    map.set(num, index);\r\n  }\r\n};\r\n\r\nconst nums = [2,7,11,15];\r\nconst target = 9;\r\nconst res = twoSum(nums, target);\r\nDeetCode.equal(res, [0,1]);",
      "notes": "Use hash map to track the index of each number. The trick is to calculate the complement of each number and see if it exists in the hash map. If so, return the indexes. For example, if the target is 9, the complement of 7 is 2.",
      "neetcode_notes": "use hash map to instantly check for difference value, map will add index of last occurrence of a num, don’t use same element twice;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018ffc6a-1658-77d4-9005-3cae379e3970",
      "category_id": "018fe6e3-6c04-79eb-997b-3153f285556f",
      "name": "Non-overlapping Intervals",
      "slug": "non-overlapping-intervals",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/non-overlapping-intervals/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/nONCGxWoUfM",
      "solution": null,
      "notes": null,
      "neetcode_notes": "instead of removing, count how max num of intervals you can include, sort intervals, dp to compute max intervals up until the i-th interval;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "018ffc6b-5c85-71ce-bbdc-33856f7832d3",
      "category_id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Valid Parentheses",
      "slug": "valid-parentheses",
      "difficulty": 1,
      "leetcode_url": "https://leetcode.com/problems/valid-parentheses/",
      "youtube_url": null,
      "neetcode_url": "https://youtu.be/WTzjTskDFMg",
      "solution": "DeetCode.enableAutoVis();\r\n\r\n/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar isValid = function(s) {\r\n    const obj = {\r\n        \"(\": \")\",\r\n        \"[\": \"]\",\r\n        \"{\": \"}\",\r\n        \")\": \"(\",\r\n        \"]\": \"[\",\r\n        \"}\": \"{\"\r\n    }\r\n    DeetCode.object(\"obj\", obj);\r\n    const stack = new Array();\r\n    for (const c of s) {\r\n        switch (c) {\r\n            case \"(\":\r\n            case \"[\":\r\n            case \"{\":\r\n                stack.push(c);\r\n                break;\r\n            case \")\":\r\n            case \"]\":\r\n            case \"}\":\r\n                if (stack.pop() !== obj[c]) {\r\n                    return false;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return stack.length === 0;\r\n};\r\n\r\nconst s = \"()[]{}\";\r\nconst res = isValid(s);\r\nDeetCode.equal(res, true);",
      "notes": "Use a stack to track opening braces. Pop if matching close brace. Return false if invalid closing brace. At the end, the string is valid if stack is empty.",
      "neetcode_notes": "push opening brace on stack, pop if matching close brace, at end if stack empty, return true;",
      "created_at": "2024-05-09T09:45:02.000Z",
      "updated_at": "2024-06-02T18:38:52.000Z",
      "default_code": null
    },
    {
      "id": "0190536e-b234-718d-9816-c3d9d7ef2e54\r\n",
      "category_id": "01905370-1855-7e70-88a5-b34c4e0758b6\r\n",
      "name": "Koko Eating Bananas",
      "slug": "koko-eating-bananas",
      "difficulty": 2,
      "leetcode_url": "https://leetcode.com/problems/koko-eating-bananas/",
      "youtube_url": null,
      "neetcode_url": null,
      "solution": "/**\r\n * @param {number[]} piles\r\n * @param {number} h\r\n * @return {number}\r\n */\r\nvar minEatingSpeed = function(piles, h) {\r\n    let l = 1;\r\n    let r = piles.reduce((p, acc) => Math.max(p, acc), -Infinity);\r\n\r\n    // vis\r\n    const rates = [];\r\n    for (let i = 0; i < r; i++) {\r\n        rates.push(i);\r\n    }\r\n    DeetCode.array(\"rates\", rates);\r\n\r\n    while (l < r) {\r\n        const k = Math.floor((l + r) / 2);\r\n        DeetCode.array(\"rates\", rates, { pointers: {l, r, k}});\r\n        const hours = calculateHoursToFinish(k);\r\n        if (hours > h) {\r\n            l = k+1;\r\n        } else if (hours <= h) {\r\n            r = k;\r\n        }\r\n    }\r\n\r\n    return l;\r\n\r\n    function calculateHoursToFinish(k) {\r\n        let hours = 0;\r\n        for (const pile of piles) {\r\n            hours += Math.ceil(pile / k);\r\n        }\r\n        return hours\r\n    }  \r\n\r\n};\r\n\r\nconst res = minEatingSpeed([3,6,7,11], 8);\r\nDeetCode.equal(res, 4);",
      "notes": null,
      "neetcode_notes": null,
      "created_at": "2024-06-26T15:27:26.000Z",
      "updated_at": "2024-06-26T15:27:26.000Z",
      "default_code": null
    }
  ],
  "categories": [
    {
      "id": "018fe6e3-6bdd-7575-89fe-a18ebfad9a68",
      "name": "Binary",
      "slug": "binary",
      "position": 4,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6bf4-74b1-a632-7f8eee599608",
      "name": "String",
      "slug": "string",
      "position": 2,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6bf7-7f61-9982-75af0b6b9964",
      "name": "Dynamic Programming",
      "slug": "dynamic-programming",
      "position": 10,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6bfa-731a-8eda-f5924821d196",
      "name": "Linked List",
      "slug": "linked-list",
      "position": 3,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6bfc-7cbf-9e7f-0996f0d5e356",
      "name": "Graph",
      "slug": "graph",
      "position": 9,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6bff-78ae-8faa-a0c0ae099baf",
      "name": "Tree",
      "slug": "tree",
      "position": 6,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6c01-7c9d-8225-5802bc33ef41",
      "name": "Matrix",
      "slug": "matrix",
      "position": 5,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6c03-7e0e-97b3-eec9ced5f80f",
      "name": "Heap",
      "slug": "heap",
      "position": 8,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6c04-79eb-997b-3153f285556f",
      "name": "Interval",
      "slug": "interval",
      "position": 7,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "018fe6e3-6c06-71fe-b8d6-366f88c9c268",
      "name": "Arrays",
      "slug": "arrays",
      "position": 1,
      "created_at": "2024-06-05T13:33:35.000Z",
      "updated_at": "2024-06-05T13:33:35.000Z"
    },
    {
      "id": "01905370-1855-7e70-88a5-b34c4e0758b6\r\n",
      "name": "Binary Search",
      "slug": "binary-search",
      "position": 11,
      "created_at": "2024-06-26T15:27:26.000Z",
      "updated_at": "2024-06-26T15:27:26.000Z"
    }
  ],
  "exportedAt": "2025-12-07T05:09:19.085Z"
}